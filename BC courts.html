<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shingw√†kons PS Badminton Club</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="Court management system for Shingw√†kons PS Badminton Club">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Badminton Club">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Badminton Club">
    
    <!-- PWA Icons for iOS -->
    <link rel="apple-touch-icon" sizes="180x180" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='40' fill='%23667eea'/%3E%3Ctext x='50' y='60' font-size='40' text-anchor='middle' fill='white'%3Eüè∏%3C/text%3E%3C/svg%3E">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='40' fill='%23667eea'/%3E%3Ctext x='50' y='60' font-size='40' text-anchor='middle' fill='white'%3Eüè∏%3C/text%3E%3C/svg%3E">
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            min-height: 100vh;
            padding: 20px;
            color: #1a202c;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 32px;
        }

        .header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            color: #1a202c;
            margin-bottom: 8px;
            letter-spacing: -0.025em;
        }

        .header .subtitle {
            font-size: 1.125rem;
            color: #64748b;
            font-weight: 400;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 32px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
            text-align: center;
            border: 1px solid #e2e8f0;
            transition: all 0.2s ease;
        }

        .stat-card:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07), 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .stat-card strong {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: #64748b;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .stat-card span {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1a202c;
        }

        .mobile-tabs {
            display: none;
            background: white;
            border-radius: 12px;
            margin-bottom: 24px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
            overflow: hidden;
        }

        .tab-buttons {
            display: flex;
            width: 100%;
        }

        .tab-btn {
            flex: 1;
            padding: 16px 12px;
            border: none;
            background: transparent;
            color: #64748b;
            font-weight: 500;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .tab-btn:not(:last-child)::after {
            content: '';
            position: absolute;
            right: 0;
            top: 20%;
            height: 60%;
            width: 1px;
            background: #e2e8f0;
        }

        .tab-btn.active {
            background: #3b82f6;
            color: white;
            font-weight: 600;
        }

        .tab-btn:hover:not(.active) {
            background: #f8fafc;
            color: #1a202c;
        }

        .main-content {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 32px;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        @media (min-width: 769px) {
            .stats-section {
                display: block !important;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 12px;
            }

            .header h1 {
                font-size: 1.75rem;
            }

            .header .subtitle {
                font-size: 1rem;
            }

            .stats {
                grid-template-columns: 1fr;
                gap: 12px;
                margin-bottom: 24px;
            }

            .stat-card {
                padding: 16px;
            }

            .mobile-tabs {
                display: block;
            }

            .main-content {
                grid-template-columns: 1fr;
                gap: 24px;
            }

            .players-section {
                display: none;
            }

            .players-section.active {
                display: block;
            }

            .courts-section {
                display: none;
            }

            .courts-section.active {
                display: grid;
            }
            
            .stats-section {
                display: none;
            }

            .stats-section.active {
                display: block;
            }
        }

        .players-section {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05), 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
            max-height: 700px;
            overflow-y: auto;
        }

        @media (max-width: 768px) {
            .players-section {
                max-height: calc(100vh - 250px);
                padding: 12px;
            }
        }

        .players-section h2 {
            margin-bottom: 24px;
            color: #1a202c;
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: -0.025em;
        }

        .player-group {
            margin-bottom: 32px;
        }

        .player-group h3 {
            color: #374151;
            margin-bottom: 12px;
            font-size: 1.125rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .player-group h3::before {
            content: '';
            width: 4px;
            height: 20px;
            background: #3b82f6;
            border-radius: 2px;
        }

        .player-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .player-item {
            padding: 12px 16px;
            background: #f8fafc;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
            font-size: 0.875rem;
            cursor: pointer;
            user-select: none;
            position: relative;
            border: 1px solid #e2e8f0;
        }

        .player-item:hover {
            background: #f1f5f9;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .player-item.available {
            background: #f0fdf4;
            border: 1px solid #16a34a;
            color: #15803d;
        }

        .player-item.playing {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            color: #d97706;
        }

        .player-item.absent {
            background: #fef2f2;
            border: 1px solid #ef4444;
            opacity: 0.7;
            text-decoration: line-through;
            color: #dc2626;
        }

        .player-item.checked-in {
            background: #eff6ff;
            border: 2px solid #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
            color: #1d4ed8;
        }

        .player-controls {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .level-toggle {
            padding: 2px 6px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 0.7em;
            cursor: pointer;
            transition: background 0.3s;
        }

        .level-toggle:hover {
            background: #1976D2;
        }

        .level-toggle:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .player-status {
            font-size: 0.75em;
            padding: 2px 6px;
            border-radius: 12px;
            background: white;
            text-transform: capitalize;
        }

        .attendance-toggle {
            margin-bottom: 15px;
            padding: 12px;
            background: #f0f0f0;
            border-radius: 10px;
        }

        .attendance-toggle h4 {
            margin-bottom: 8px;
            color: #666;
            font-size: 0.9em;
        }

        .toggle-buttons {
            display: flex;
            gap: 8px;
        }

        .toggle-btn {
            padding: 6px 12px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 5px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.3s;
        }

        .toggle-btn:hover {
            background: #f5f5f5;
        }

        .toggle-btn.mark-all {
            background: #4caf50;
            color: white;
            border-color: #4caf50;
        }

        .toggle-btn.mark-absent {
            background: #f44336;
            color: white;
            border-color: #f44336;
        }

        .courts-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 24px;
        }

        @media (max-width: 768px) {
            .courts-section {
                grid-template-columns: 1fr;
                gap: 10px;
            }
        }

        .court-card {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05), 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
            transition: all 0.2s ease;
        }

        @media (min-width: 769px) {
            .court-card:hover {
                transform: translateY(-2px);
                box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1), 0 4px 10px rgba(0, 0, 0, 0.05);
            }
        }

        @media (max-width: 768px) {
            .court-card {
                padding: 12px;
            }
        }

        .court-header {
            text-align: center;
            margin-bottom: 12px;
        }

        .court-number {
            display: inline-block;
            background: #3b82f6;
            color: white;
            padding: 8px 16px;
            border-radius: 24px;
            font-weight: 600;
            font-size: 0.875rem;
            letter-spacing: 0.025em;
        }

        .court-status {
            text-align: center;
            padding: 12px 16px;
            margin: 16px 0;
            border-radius: 10px;
            font-weight: 500;
            font-size: 0.875rem;
        }

        .court-status.empty {
            background: #f8fafc;
            color: #64748b;
            border: 1px solid #e2e8f0;
        }

        .court-status.occupied {
            background: #f0fdf4;
            color: #15803d;
            border: 1px solid #16a34a;
        }

        .players-on-court {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }

        .player-on-court {
            padding: 8px;
            background: #f0f4ff;
            border-radius: 8px;
            text-align: center;
            font-size: 0.9em;
        }

        .player-on-court.intermediate {
            background: #fff3e0;
        }

        .btn {
            width: 100%;
            padding: 12px 16px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .btn-end {
            background: #ef4444;
            color: white;
        }

        .btn-end:hover:not(:disabled) {
            background: #dc2626;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(239, 68, 68, 0.3);
        }

        .btn-assign {
            background: #16a34a;
            color: white;
        }

        .btn-assign:hover:not(:disabled) {
            background: #15803d;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(22, 163, 74, 0.3);
        }

        .btn:disabled {
            background: #e5e7eb;
            color: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .queue-info {
            text-align: center;
            margin-top: 10px;
            font-size: 0.9em;
            color: #666;
        }

        /* Timer Styles */
        .timer-display {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 8px 12px;
            margin: 10px 0;
            text-align: center;
            font-family: 'Courier New', monospace;
            transition: all 0.3s ease;
        }

        .timer-display.active {
            background: #e8f5e9;
            border-color: #4caf50;
            animation: pulse 2s infinite;
        }

        .timer-display.stopped {
            background: #ffebee;
            border-color: #f44336;
        }

        .timer-display.paused {
            background: #fff8e1;
            border-color: #ff9800;
        }

        .timer-icon {
            font-size: 1.1em;
            margin-right: 5px;
        }

        .timer-time {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            margin: 0 8px;
        }

        .timer-display.active .timer-time {
            color: #2e7d32;
        }

        .timer-display.stopped .timer-time {
            color: #c62828;
        }

        .timer-label {
            font-size: 0.8em;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-left: 5px;
        }

        .timer-display.active .timer-label {
            color: #2e7d32;
        }

        .timer-display.stopped .timer-label {
            color: #c62828;
        }

        .timer-display.paused .timer-time {
            color: #f57c00;
        }

        .timer-display.paused .timer-label {
            color: #f57c00;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        /* Timer controls */
        .timer-controls {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }

        .timer-btn {
            flex: 1;
            padding: 4px 8px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .timer-btn:hover {
            background: #f5f5f5;
        }

        .timer-btn.start {
            background: #4caf50;
            color: white;
            border-color: #4caf50;
        }

        .timer-btn.start:hover {
            background: #45a049;
        }

        .timer-btn.stop {
            background: #f44336;
            color: white;
            border-color: #f44336;
        }

        .timer-btn.stop:hover {
            background: #d32f2f;
        }

        .timer-btn:disabled {
            background: #e9ecef;
            color: #6c757d;
            cursor: not-allowed;
        }

        /* Manual Assignment Styles */
        .btn-manual {
            background: #3b82f6;
            color: white;
            margin-top: 8px;
        }

        .btn-manual:hover:not(:disabled) {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }

        .assignment-buttons {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .assignment-buttons .btn {
            margin: 0;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 20px;
            border-radius: 10px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eee;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: #000;
        }

        .player-selection {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .player-option {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
        }

        .player-option:hover {
            border-color: #2196F3;
            background-color: #f0f8ff;
        }

        .player-option.selected {
            border-color: #4caf50;
            background-color: #e8f5e9;
            color: #2e7d32;
        }

        .player-option.intermediate {
            background-color: #fff3e0;
        }

        .player-option.beginner {
            background-color: #f0f4ff;
        }

        .selected-count {
            text-align: center;
            margin: 15px 0;
            font-weight: bold;
            font-size: 1.1em;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-btn-primary {
            background: #4caf50;
            color: white;
        }

        .modal-btn-primary:hover {
            background: #45a049;
        }

        .modal-btn-secondary {
            background: #f44336;
            color: white;
        }

        .modal-btn-secondary:hover {
            background: #d32f2f;
        }

        .add-player-form {
            margin-bottom: 15px;
            padding: 12px;
            background: #f9f9f9;
            border-radius: 10px;
        }

        .form-group {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .form-group input {
            flex: 1;
            min-width: 150px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .form-group select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .add-player-form {
                padding: 10px;
            }

            .form-group {
                flex-direction: column;
            }

            .form-group input,
            .form-group select {
                width: 100%;
            }
        }

        /* Touch-friendly buttons for mobile */
        @media (max-width: 768px) {
            .btn {
                padding: 12px;
                font-size: 0.95em;
                -webkit-tap-highlight-color: transparent;
            }
        }

        /* Improve scrolling on mobile */
        @media (max-width: 768px) {
            .players-section,
            .courts-section {
                -webkit-overflow-scrolling: touch;
            }
        }

        /* Loading indicator for better UX */
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }

        /* Statistics Dashboard Styles */
        .stats-section {
            background: white;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: none;
        }

        .stats-section.active {
            display: block;
        }

        .stats-section h2 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.3em;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            border: 1px solid #e9ecef;
        }

        .stat-panel h3 {
            margin-bottom: 12px;
            color: #495057;
            font-size: 1em;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 8px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-size: 0.9em;
            color: #6c757d;
        }

        .stat-value {
            font-weight: bold;
            color: #495057;
            font-size: 0.95em;
        }

        .player-stats-controls {
            margin-bottom: 12px;
        }

        .player-stats-controls select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .wait-time-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            border: 1px solid #e9ecef;
        }

        .wait-time-panel h3 {
            margin-bottom: 12px;
            color: #495057;
            font-size: 1em;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 8px;
        }

        .wait-time-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin: 6px 0;
            background: white;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .wait-time-player {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .wait-time-position {
            background: #667eea;
            color: white;
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 0.75em;
            min-width: 20px;
            text-align: center;
        }

        .wait-time-estimate {
            font-weight: bold;
            color: #495057;
            text-align: right;
        }

        .wait-time-actual {
            font-size: 0.8em;
            color: #6c757d;
            text-align: right;
            margin-top: 2px;
        }

        .wait-time-estimate.short {
            color: #28a745;
        }

        .wait-time-estimate.medium {
            color: #ffc107;
        }

        .wait-time-estimate.long {
            color: #dc3545;
        }

        .court-usage-bar {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }

        .court-usage-label {
            width: 60px;
            font-size: 0.9em;
            color: #6c757d;
        }

        .court-usage-progress {
            flex: 1;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 0 10px;
        }

        .court-usage-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
        }

        .court-usage-percent {
            font-size: 0.85em;
            font-weight: bold;
            color: #495057;
            min-width: 35px;
        }

        .player-stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            margin: 4px 0;
            background: white;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            font-size: 0.85em;
        }

        .player-stat-name {
            font-weight: bold;
            color: #495057;
        }

        .player-stat-value {
            color: #6c757d;
        }

        .recent-game-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            margin: 6px 0;
            background: white;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            font-size: 0.85em;
        }

        .recent-game-info {
            flex: 1;
        }

        .recent-game-court {
            font-weight: bold;
            color: #667eea;
        }

        .recent-game-players {
            color: #6c757d;
            margin-top: 2px;
        }

        .recent-game-duration {
            font-weight: bold;
            color: #495057;
        }

        @media (max-width: 768px) {
            .stats-section {
                max-height: calc(100vh - 250px);
                overflow-y: auto;
                padding: 12px;
            }

            .stats-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }

            .stat-panel {
                padding: 12px;
            }

            .wait-time-panel {
                padding: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè∏ Shingw√†kons PS Badminton Club</h1>
            <div class="subtitle">Court Management System</div>
        </div>

        <div class="stats">
                <div class="stat-card">
                    <strong>Total Players:</strong> <span id="totalPlayers">34</span>
                </div>
                <div class="stat-card">
                    <strong>Available Courts:</strong> <span id="availableCourts">4</span>
                </div>
                <div class="stat-card">
                    <strong>Active Games:</strong> <span id="activeGames">0</span>
                </div>
            </div>
        </div>

        <div class="mobile-tabs">
            <div class="tab-buttons">
                <button class="tab-btn active" onclick="switchTab('players')">Players</button>
                <button class="tab-btn" onclick="switchTab('courts')">Courts</button>
                <button class="tab-btn" onclick="switchTab('stats')">Stats</button>
            </div>
        </div>

        <div class="main-content">
            <div class="players-section active" id="playersSection">
                <h2>Players Management</h2>
                
                <div class="add-player-form">
                    <div class="form-group">
                        <input type="text" id="newPlayerName" placeholder="Player name (or Guest 1, Guest 2, etc.)">
                        <select id="newPlayerLevel">
                            <option value="beginner">Beginner</option>
                            <option value="intermediate">Intermediate</option>
                            <option value="guest-beginner">Guest (Beginner)</option>
                            <option value="guest-intermediate">Guest (Intermediate)</option>
                        </select>
                    </div>
                    <button class="btn btn-assign" onclick="addPlayer()">Add Player</button>
                </div>

                <div class="attendance-toggle">
                    <h4>Quick Attendance Actions</h4>
                    <div class="toggle-buttons">
                        <button class="toggle-btn mark-all" onclick="markAllPresent()">Mark All Present</button>
                        <button class="toggle-btn mark-absent" onclick="markAllAbsent()">Mark All Absent</button>
                    </div>
                </div>

                <div class="attendance-toggle">
                    <h4>Game Settings</h4>
                    <div class="form-group">
                        <label for="avgGameDurationSetting">Average Game Duration (minutes):</label>
                        <input type="number" id="avgGameDurationSetting" min="5" max="60" value="15" onchange="updateGameDurationSetting()">
                        <small style="color: #666; font-size: 0.8em;">Used for wait time calculations</small>
                    </div>
                </div>

                <div class="attendance-toggle">
                    <h4>Data Management</h4>
                    <div class="toggle-buttons">
                        <button class="toggle-btn" onclick="clearAllData()" style="background: #ff5722; border-color: #ff5722;">Reset All Data</button>
                        <button class="toggle-btn" onclick="clearCache()" style="background: #9c27b0; border-color: #9c27b0;">Clear Cache</button>
                    </div>
                </div>

                <div class="player-group">
                    <h3>Intermediate Players (<span id="intermediateCount">10</span>)</h3>
                    <p style="font-size: 0.8em; color: #666; margin-bottom: 8px;">Click player name to toggle attendance ‚Ä¢ Click ‚óã to check in ‚Ä¢ Click ‚úì to check out</p>
                    <div class="player-list" id="intermediatePlayers"></div>
                </div>

                <div class="player-group">
                    <h3>Beginner Players (<span id="beginnerCount">24</span>)</h3>
                    <p style="font-size: 0.8em; color: #666; margin-bottom: 8px;">Click player name to toggle attendance ‚Ä¢ Click ‚óã to check in ‚Ä¢ Click ‚úì to check out</p>
                    <div class="player-list" id="beginnerPlayers"></div>
                </div>
            </div>

            <div class="courts-section" id="courtsSection">
                <!-- Courts will be dynamically generated -->
            </div>

            <div class="stats-section" id="statsSection">
                <h2>üìä Statistics & Analytics</h2>
                
                <div class="stats-grid">
                    <div class="stat-panel">
                        <h3>üéØ Session Overview</h3>
                        <div class="stat-item">
                            <span class="stat-label">Games Completed:</span>
                            <span class="stat-value" id="totalGamesCompleted">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Total Play Time:</span>
                            <span class="stat-value" id="totalPlayTime">0:00</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Average Game Duration:</span>
                            <span class="stat-value" id="avgGameDuration">0:00</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Session Duration:</span>
                            <span class="stat-value" id="sessionDuration">0:00</span>
                        </div>
                    </div>

                    <div class="stat-panel">
                        <h3>üè∏ Court Utilization</h3>
                        <div id="courtUtilization">
                            <!-- Court usage stats will be populated here -->
                        </div>
                    </div>

                    <div class="stat-panel">
                        <h3>üë• Player Statistics</h3>
                        <div class="player-stats-controls">
                            <select id="playerStatsFilter">
                                <option value="all">All Players</option>
                                <option value="intermediate">Intermediate</option>
                                <option value="beginner">Beginner</option>
                            </select>
                        </div>
                        <div id="playerStatsContainer">
                            <!-- Player stats will be populated here -->
                        </div>
                    </div>

                    <div class="stat-panel">
                        <h3>üìà Recent Games</h3>
                        <div id="recentGamesContainer">
                            <!-- Recent game history will be populated here -->
                        </div>
                    </div>
                </div>

                <div class="wait-time-panel">
                    <h3>üìã Current Queue</h3>
                    <div id="waitTimeContainer">
                        <!-- Current queue will be populated here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>

        // Check if mobile
        function isMobile() {
            return window.innerWidth <= 768;
        }

        // Auto switch to courts tab on mobile when assigning
        function assignPlayers(courtId) {
            const court = courts.find(c => c.id === courtId);
            if (court.occupied) return;

            const availableIntermediate = players.intermediate.filter(p => p.status === 'available' && p.checkedIn);
            const availableBeginner = players.beginner.filter(p => p.status === 'available' && p.checkedIn);

            let selectedPlayers = [];

            // All courts are assigned based on checked-in availability
                // Prioritize intermediate players if we have 4 or more
                if (availableIntermediate.length >= 4) {
                    selectedPlayers = getRandomPlayers(availableIntermediate, 4);
                    console.log(`Court ${courtId} (Mixed): Selected intermediate players - ${selectedPlayers.map(p => p.name).join(', ')}`);
                } else if (availableBeginner.length >= 4) {
                    selectedPlayers = getRandomPlayers(availableBeginner, 4);
                    console.log(`Court ${courtId} (Mixed): Selected beginner players - ${selectedPlayers.map(p => p.name).join(', ')}`);
                } else if (availableIntermediate.length + availableBeginner.length >= 4) {
                    // Mixed level game when not enough of single level but combined >= 4
                    const mixedPlayers = [...availableIntermediate, ...availableBeginner];
                    selectedPlayers = getRandomPlayers(mixedPlayers, 4);
                    console.log(`Court ${courtId} (Mixed Levels): Selected mixed players - ${selectedPlayers.map(p => `${p.name}(${p.level})`).join(', ')}`);
                } else {
                    alert(`Not enough checked-in players for Court ${courtId}. Need 4 checked-in players but only ${availableIntermediate.length} intermediate and ${availableBeginner.length} beginner players are checked in.`);
                    return;
                }

            // Update player status
            selectedPlayers.forEach(player => {
                player.status = 'playing';
            });

            // Update court
            court.occupied = true;
            court.players = selectedPlayers;

            // Start the timer for this court
            startCourtTimer(courtId);

            renderPlayers();
            renderCourts();
            updateStats();
            updateWaitTimes(); // Update wait times after assignment
            
            // Send push notifications
            checkForPlayerTurn(selectedPlayers);
            
            // Voice announcement
            const playerNames = selectedPlayers.map(p => p.name);
            announcePlayerNames(playerNames);
            
            // Sync court assignment to Firebase
            console.log('üè∏ Syncing court assignment to Firebase');
            savePlayersDataWithSync();

            // Switch to courts tab on mobile after assigning
            if (isMobile()) {
                setTimeout(() => switchTab('courts'), 100);
            }
        }

        // Game state
        let players = {
            intermediate: [],
            beginner: []
        };

        let courts = [
            { id: 1, occupied: false, players: [], startTime: null, elapsedTime: 0 },
            { id: 2, occupied: false, players: [], startTime: null, elapsedTime: 0 },
            { id: 3, occupied: false, players: [], startTime: null, elapsedTime: 0 },
            { id: 4, occupied: false, players: [], startTime: null, elapsedTime: 0 }
        ];

        // Statistics and Analytics
        let gameHistory = []; // Store completed games
        let playerStats = {}; // Store individual player statistics
        let sessionStats = {
            startTime: Date.now(),
            totalGames: 0,
            totalPlayTime: 0,
            averageGameDuration: 0
        };

        // Game settings
        let gameSettings = {
            defaultGameDuration: 15 * 60 * 1000 // 15 minutes in milliseconds
        };

        // Timer management
        let timerInterval = null;
        let waitTimeUpdateInterval = null;

        // Start timer for a court
        function startCourtTimer(courtId) {
            const court = courts.find(c => c.id === courtId);
            if (court && court.occupied) {
                if (!court.startTime) {
                    // Starting fresh or resuming - adjust start time based on elapsed time
                    court.startTime = Date.now() - (court.elapsedTime || 0);
                    console.log(`‚è±Ô∏è Timer started for Court ${courtId} (resuming from ${formatTime(court.elapsedTime || 0)})`);
                } else {
                    console.log(`‚è±Ô∏è Timer already running for Court ${courtId}`);
                    return;
                }
                
                // Start the global timer update if not already running
                if (!timerInterval) {
                    timerInterval = setInterval(updateAllTimers, 1000);
                }
                
                // Update display immediately
                renderCourts();
            }
        }

        // Pause timer for a court (stops timer but keeps elapsed time)
        function pauseCourtTimer(courtId) {
            const court = courts.find(c => c.id === courtId);
            if (court && court.startTime) {
                // Calculate total elapsed time including current session
                court.elapsedTime = Date.now() - court.startTime;
                court.startTime = null; // Mark as paused
                console.log(`‚è∏Ô∏è Timer paused for Court ${courtId}. Duration: ${formatTime(court.elapsedTime)}`);
                
                // Stop global timer if no courts are active
                const anyActiveTimer = courts.some(c => c.startTime !== null);
                if (!anyActiveTimer && timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
                
                // Update display immediately
                renderCourts();
            }
        }

        // Stop timer for a court (used when ending game)
        function stopCourtTimer(courtId) {
            const court = courts.find(c => c.id === courtId);
            if (court) {
                if (court.startTime) {
                    // Calculate final elapsed time
                    court.elapsedTime = Date.now() - court.startTime;
                }
                const finalTime = court.elapsedTime || 0;
                console.log(`üèÅ Timer stopped for Court ${courtId}. Final Duration: ${formatTime(finalTime)}`);
                
                // Reset timer data
                court.startTime = null;
                court.elapsedTime = 0;
                
                // Stop global timer if no courts are active
                const anyActiveTimer = courts.some(c => c.startTime !== null);
                if (!anyActiveTimer && timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
                
                return finalTime; // Return final time for game end summary
            }
            return 0;
        }

        // Update all active timers
        function updateAllTimers() {
            let hasActiveTimer = false;
            courts.forEach(court => {
                if (court.startTime && court.occupied) {
                    hasActiveTimer = true;
                    court.elapsedTime = Date.now() - court.startTime;
                }
            });
            
            // Update the display
            renderCourts();
            
            // Stop interval if no active timers
            if (!hasActiveTimer) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        // Format time in MM:SS format
        function formatTime(milliseconds) {
            const totalSeconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Get timer display for a court
        function getTimerDisplay(court) {
            if (!court.occupied) {
                return '';
            }
            
            let timeToShow = 0;
            if (court.startTime) {
                timeToShow = Date.now() - court.startTime;
            } else if (court.elapsedTime > 0) {
                timeToShow = court.elapsedTime;
            }
            
            const formattedTime = formatTime(timeToShow);
            const isActive = court.startTime !== null;
            const isPaused = !isActive && court.elapsedTime > 0;
            
            let statusIcon, statusLabel, statusClass;
            if (isActive) {
                statusIcon = 'üü¢';
                statusLabel = 'Playing';
                statusClass = 'active';
            } else if (isPaused) {
                statusIcon = 'üü°';
                statusLabel = 'Paused';
                statusClass = 'paused';
            } else {
                statusIcon = 'üî¥';
                statusLabel = 'Stopped';
                statusClass = 'stopped';
            }
            
            return `
                <div class="timer-display ${statusClass}">
                    <span class="timer-icon">${statusIcon}</span>
                    <span class="timer-time">${formattedTime}</span>
                    <span class="timer-label">${statusLabel}</span>
                </div>
            `;
        }

        // Save players data to localStorage
        function savePlayersData() {
            try {
                const dataToSave = {
                    players: players,
                    courts: courts,
                    gameHistory: gameHistory,
                    playerStats: playerStats,
                    sessionStats: sessionStats,
                    gameSettings: gameSettings,
                    timestamp: Date.now()
                };
                localStorage.setItem('badmintonClubData', JSON.stringify(dataToSave));
                console.log('‚úÖ Data saved to localStorage');
            } catch (error) {
                console.error('‚ùå Error saving data:', error);
            }
        }

        // Load players data from localStorage
        function loadPlayersData() {
            try {
                const savedData = localStorage.getItem('badmintonClubData');
                if (savedData) {
                    const parsedData = JSON.parse(savedData);
                    
                    // Load saved players data
                    if (parsedData.players) {
                        players = parsedData.players;
                        console.log('‚úÖ Loaded saved player data');
                    }
                    
                    // Load statistics data
                    if (parsedData.gameHistory) {
                        gameHistory = parsedData.gameHistory;
                        console.log('‚úÖ Loaded game history');
                    }
                    
                    if (parsedData.playerStats) {
                        playerStats = parsedData.playerStats;
                        console.log('‚úÖ Loaded player statistics');
                    }
                    
                    if (parsedData.sessionStats) {
                        sessionStats = { ...sessionStats, ...parsedData.sessionStats };
                        // Reset session start time to current session
                        sessionStats.startTime = Date.now();
                        console.log('‚úÖ Loaded session statistics');
                    }
                    
                    if (parsedData.gameSettings) {
                        gameSettings = { ...gameSettings, ...parsedData.gameSettings };
                        console.log('‚úÖ Loaded game settings');
                    }
                    
                    // Reset courts (don't persist games across sessions)
                    courts.forEach(court => {
                        court.occupied = false;
                        court.players = [];
                    });
                    
                    // Ensure all players are available (reset playing status)
                    players.intermediate.forEach(player => {
                        if (player.status === 'playing') {
                            player.status = 'available';
                        }
                    });
                    players.beginner.forEach(player => {
                        if (player.status === 'playing') {
                            player.status = 'available';
                        }
                    });
                    
                    return true; // Data was loaded
                }
            } catch (error) {
                console.error('‚ùå Error loading data:', error);
            }
            return false; // No data was loaded
        }

        // Initialize players with default data or load from storage
        function initializePlayers() {
            // Try to load saved data first
            if (loadPlayersData()) {
                console.log('üìÇ Loaded existing player data from storage');
                renderPlayers();
                renderCourts();
                updateStats();
                return;
            }

            // If no saved data, create default players
            console.log('üÜï Creating default player data');
            
            // Add intermediate players (14 players - updated)
            const intermediatePlayerNames = [
                'Ali',
                'Arslan Rafique',
                'Arslan Shahid',
                'Asad',
                'Awais',
                'Ghazanfar',
                'Hamid',
                'Mohsin',
                'Mavia',
                'Najam Saqib',
                'Shehryar',
                'Umair Masood',
                'Usman',
                'Waqas'
            ];

            intermediatePlayerNames.forEach((name, index) => {
                players.intermediate.push({
                    id: `int${index + 1}`,
                    name: name,
                    status: 'available',
                    level: 'intermediate',
                    checkedIn: false, // Players start unchecked
                    queueTimestamp: Date.now() // Track when they became available
                });
            });

            // Add beginner players (18 players - updated)
            const beginnerPlayerNames = [
                'Abdul Aziz',
                'Abrar',
                'Aditya',
                'Amarnath',
                'Amir',
                'Anas',
                'Ankur',
                'Danial',
                'Haider',
                'Imran',
                'Karthik',
                'Khizar',
                'Mohiuddin',
                'Paritosh',
                'Rizwan',
                'Saad',
                'Srinandni',
                'Vignesh'
            ];

            beginnerPlayerNames.forEach((name, index) => {
                players.beginner.push({
                    id: `beg${index + 1}`,
                    name: name,
                    status: 'available',
                    level: 'beginner',
                    checkedIn: false, // Players start unchecked
                    queueTimestamp: Date.now() // Track when they became available
                });
            });

            // Save the initial data
            savePlayersData();

            renderPlayers();
            renderCourts();
            updateStats();
            
        }


        // Toggle check-in status for a player
        function toggleCheckIn(playerId, level) {
            const player = players[level].find(p => p.id === playerId);
            if (!player) {
                console.error(`Player not found: ${playerId} in ${level}`);
                return;
            }

            if (player.status !== 'available') {
                alert('Player must be available to check in/out');
                return;
            }

            if (player.checkedIn) {
                // Check out
                player.checkedIn = false;
                console.log(`${player.name} checked out`);
                showConnectionStatus(`${player.name} checked out`);
            } else {
                // Check in
                player.checkedIn = true;
                player.queueTimestamp = Date.now(); // Reset queue position when checking in
                console.log(`${player.name} checked in`);
                showConnectionStatus(`${player.name} checked in`);
            }

            renderPlayers();
            updateWaitTimes(); // Update queue display
            savePlayersDataWithSync();
        }

        // Voice announcement function
        function announcePlayerNames(playerNames) {
            if ('speechSynthesis' in window) {
                const announcement = `Now playing: ${playerNames.join(', ')}`;
                const utterance = new SpeechSynthesisUtterance(announcement);
                utterance.rate = 0.8;
                utterance.volume = 0.8;
                utterance.pitch = 1.0;
                
                // Try to use a clear voice
                const voices = speechSynthesis.getVoices();
                const englishVoice = voices.find(voice => 
                    voice.lang.startsWith('en') && (voice.name.includes('Google') || voice.name.includes('Microsoft'))
                );
                if (englishVoice) {
                    utterance.voice = englishVoice;
                }
                
                speechSynthesis.speak(utterance);
                console.log('üîä Announced:', announcement);
            } else {
                console.log('üîá Speech synthesis not supported');
            }
        }

        // Add new player
        function addPlayer() {
            const name = document.getElementById('newPlayerName').value.trim();
            const levelSelect = document.getElementById('newPlayerLevel').value;

            if (!name) {
                alert('Please enter a player name');
                return;
            }

            // Determine the actual level and if it's a guest
            let level = levelSelect.includes('guest-') ? levelSelect.replace('guest-', '') : levelSelect;
            let displayName = levelSelect.includes('guest-') ? `${name} (Guest)` : name;

            // Check for duplicate names across all players
            const allPlayers = [...players.intermediate, ...players.beginner];
            const duplicateName = allPlayers.find(p => p.name.toLowerCase() === displayName.toLowerCase());
            if (duplicateName) {
                alert(`A player named "${duplicateName.name}" already exists! Please choose a different name.`);
                return;
            }

            const player = {
                id: `${level}_${Date.now()}`,
                name: displayName,
                status: 'available',
                level: level,
                isGuest: levelSelect.includes('guest-'),
                checkedIn: false, // New players are not checked in by default
                queueTimestamp: Date.now() // New players go to end of queue
            };

            players[level].push(player);
            
            document.getElementById('newPlayerName').value = '';
            
            renderPlayers();
            updateStats();
            savePlayersDataWithSync(); // Save after adding new player
        }

        // Render players list
        function renderPlayers() {
            const intermediateContainer = document.getElementById('intermediatePlayers');
            const beginnerContainer = document.getElementById('beginnerPlayers');

            intermediateContainer.innerHTML = '';
            beginnerContainer.innerHTML = '';

            players.intermediate.forEach(player => {
                intermediateContainer.appendChild(createPlayerElement(player));
            });

            players.beginner.forEach(player => {
                beginnerContainer.appendChild(createPlayerElement(player));
            });

            document.getElementById('intermediateCount').textContent = players.intermediate.length;
            document.getElementById('beginnerCount').textContent = players.beginner.length;
        }

        // Create player element
        function createPlayerElement(player) {
            const div = document.createElement('div');
            let className = `player-item ${player.status}`;
            if (player.checkedIn && player.status === 'available') {
                className += ' checked-in';
            }
            div.className = className;
            
            let statusText = player.status;
            if (player.status === 'absent') {
                statusText = 'absent';
            } else if (player.status === 'playing') {
                statusText = 'playing';
            } else if (player.checkedIn) {
                statusText = 'checked in';
            } else {
                statusText = 'present';
            }
            
            const targetLevel = player.level === 'intermediate' ? 'beginner' : 'intermediate';
            const buttonText = player.level === 'intermediate' ? '‚Üí Beg' : '‚Üí Int';
            const isPlaying = player.status === 'playing';
            const isAbsent = player.status === 'absent';
            
            // Add click handler to the entire div
            div.onclick = function(event) {
                // Don't trigger if clicking on control buttons
                if (event.target.classList.contains('level-toggle') || 
                    event.target.classList.contains('delete-btn') || 
                    event.target.classList.contains('rename-btn') ||
                    event.target.classList.contains('checkin-btn')) {
                    return;
                }
                console.log('Click detected on', player.name);
                togglePlayerAttendanceById(player.id, player.level);
            };
            
            // Check-in button (only show if present and not playing)
            let checkinButton = '';
            if (player.status === 'available' && !isPlaying) {
                if (player.checkedIn) {
                    checkinButton = `<button class="checkin-btn" onclick="event.stopPropagation(); toggleCheckIn('${player.id}', '${player.level}')" title="Check out" style="padding: 2px 6px; background: #28a745; color: white; border: none; border-radius: 4px; font-size: 0.7em; cursor: pointer; margin-left: 3px;">‚úì</button>`;
                } else {
                    checkinButton = `<button class="checkin-btn" onclick="event.stopPropagation(); toggleCheckIn('${player.id}', '${player.level}')" title="Check in" style="padding: 2px 6px; background: #6c757d; color: white; border: none; border-radius: 4px; font-size: 0.7em; cursor: pointer; margin-left: 3px;">‚óã</button>`;
                }
            }
            
            div.innerHTML = `
                <span style="flex: 1;">${player.name}</span>
                <div class="player-controls">
                    <button class="level-toggle" onclick="event.stopPropagation(); changePlayerLevel('${player.id}', '${player.level}', '${targetLevel}')" ${isPlaying ? 'disabled' : ''} title="Move to ${targetLevel}">
                        ${buttonText}
                    </button>
                    ${checkinButton}
                    <button class="rename-btn" onclick="event.stopPropagation(); renamePlayer('${player.id}', '${player.level}')" ${isPlaying ? 'disabled' : ''} title="Rename player" style="padding: 2px 6px; background: #2196F3; color: white; border: none; border-radius: 4px; font-size: 0.7em; cursor: pointer; margin-left: 3px;">
                        ‚úèÔ∏è
                    </button>
                    <button class="delete-btn" onclick="event.stopPropagation(); deletePlayer('${player.id}', '${player.level}')" ${isPlaying ? 'disabled' : ''} title="Delete player" style="padding: 2px 6px; background: #f44336; color: white; border: none; border-radius: 4px; font-size: 0.7em; cursor: pointer; margin-left: 3px;">
                        üóëÔ∏è
                    </button>
                    <span class="player-status">${statusText}</span>
                </div>
            `;
            return div;
        }

        // Change player level
        function changePlayerLevel(playerId, currentLevel, targetLevel) {
            // Find the player in current level
            const playerIndex = players[currentLevel].findIndex(p => p.id === playerId);
            if (playerIndex === -1) return;
            
            const player = players[currentLevel][playerIndex];
            
            // Can't move if playing
            if (player.status === 'playing') {
                alert('Cannot change level while player is in a game!');
                return;
            }
            
            // Remove from current level
            players[currentLevel].splice(playerIndex, 1);
            
            // Change level and add to target level
            player.level = targetLevel;
            players[targetLevel].push(player);
            
            // Sort players by name for better organization
            players[targetLevel].sort((a, b) => a.name.localeCompare(b.name));
            
            renderPlayers();
            updateStats();
            savePlayersDataWithSync(); // Save after level change
            
            console.log(`Moved ${player.name} from ${currentLevel} to ${targetLevel}`);
        }

        // Delete player function
        function deletePlayer(playerId, level) {
            const player = players[level].find(p => p.id === playerId);
            if (!player) {
                console.error(`Player not found: ${playerId} in ${level}`);
                return;
            }

            if (player.status === 'playing') {
                alert('Cannot delete a player who is currently playing. End their game first.');
                return;
            }

            const confirmDelete = confirm(`Are you sure you want to delete "${player.name}"? This action cannot be undone.`);
            if (confirmDelete) {
                const playerIndex = players[level].findIndex(p => p.id === playerId);
                players[level].splice(playerIndex, 1);
                
                console.log(`Deleted player: ${player.name}`);
                renderPlayers();
                updateStats();
                savePlayersDataWithSync(); // Save after deletion
            }
        }

        // Rename player function
        function renamePlayer(playerId, level) {
            const player = players[level].find(p => p.id === playerId);
            if (!player) {
                console.error(`Player not found: ${playerId} in ${level}`);
                return;
            }

            if (player.status === 'playing') {
                alert('Cannot rename a player who is currently playing. End their game first.');
                return;
            }

            const newName = prompt(`Enter new name for "${player.name}":`, player.name);
            if (newName && newName.trim() && newName.trim() !== player.name) {
                const trimmedName = newName.trim();
                
                // Check for duplicate names across all players (excluding current player)
                const allPlayers = [...players.intermediate, ...players.beginner];
                const duplicateName = allPlayers.find(p => p.id !== playerId && p.name.toLowerCase() === trimmedName.toLowerCase());
                if (duplicateName) {
                    alert(`A player named "${duplicateName.name}" already exists! Please choose a different name.`);
                    return;
                }
                
                const oldName = player.name;
                player.name = trimmedName;
                
                console.log(`Renamed player: "${oldName}" ‚Üí "${player.name}"`);
                renderPlayers();
                savePlayersDataWithSync(); // Save after rename
            }
        }

        // Toggle player attendance by ID and level
        function togglePlayerAttendanceById(playerId, level) {
            
            const player = players[level].find(p => p.id === playerId);
            if (!player) {
                console.error(`Player not found: ${playerId} in ${level}`);
                alert(`Player not found: ${playerId}`);
                return;
            }
            
            togglePlayerAttendance(player);
        }

        // Toggle player attendance
        function togglePlayerAttendance(player) {
            if (!player) return;
            
            if (player.status === 'playing') {
                alert('Cannot mark a playing player as absent. End their game first.');
                return;
            }
            
            if (player.status === 'absent') {
                player.status = 'available';
                // When player returns from absent, they get a new queue timestamp (go to end of queue)
                player.queueTimestamp = Date.now();
            } else {
                player.status = 'absent';
            }
            
            renderPlayers();
            updateStats();
            savePlayersDataWithSync(); // Save after attendance change
        }

        // Mark all players as present
        function markAllPresent() {
            players.intermediate.forEach(player => {
                if (player.status === 'absent') {
                    player.status = 'available';
                }
            });
            players.beginner.forEach(player => {
                if (player.status === 'absent') {
                    player.status = 'available';
                }
            });
            renderPlayers();
            updateStats();
            savePlayersDataWithSync(); // Save after bulk attendance change
        }

        // Mark all players as absent
        function markAllAbsent() {
            if (confirm('This will mark all non-playing players as absent. Continue?')) {
                players.intermediate.forEach(player => {
                    if (player.status !== 'playing') {
                        player.status = 'absent';
                    }
                });
                players.beginner.forEach(player => {
                    if (player.status !== 'playing') {
                        player.status = 'absent';
                    }
                });
                renderPlayers();
                updateStats();
                savePlayersDataWithSync(); // Save after bulk attendance change
            }
        }

        // Render courts
        function renderCourts() {
            const container = document.getElementById('courtsSection');
            container.innerHTML = '';

            courts.forEach(court => {
                const courtCard = createCourtCard(court);
                container.appendChild(courtCard);
            });
        }

        // Create court card
        function createCourtCard(court) {
            const div = document.createElement('div');
            div.className = 'court-card';

            const statusClass = court.occupied ? 'occupied' : 'empty';
            const statusText = court.occupied ? 'Game in Progress' : 'Court Available';

            let playersHTML = '';
            if (court.occupied && court.players.length === 4) {
                playersHTML = `
                    <div class="players-on-court">
                        ${court.players.map(p => `
                            <div class="player-on-court ${p.level}">${p.name}</div>
                        `).join('')}
                    </div>
                `;
            }

            const queueInfo = getQueueInfo(court);

            // No special indicators for any courts
            const courtSpecialInfo = '';

            div.innerHTML = `
                <div class="court-header">
                    <span class="court-number">Court ${court.id}</span>
                </div>
                ${courtSpecialInfo}
                <div class="court-status ${statusClass}">${statusText}</div>
                ${getTimerDisplay(court)}
                ${playersHTML}
                ${court.occupied ? 
                    `<div class="timer-controls">
                        <button class="timer-btn ${court.startTime ? 'stop' : 'start'}" onclick="${court.startTime ? `pauseCourtTimer(${court.id})` : `startCourtTimer(${court.id})`}" ${!court.occupied ? 'disabled' : ''}>
                            ${court.startTime ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Resume'}
                        </button>
                        <button class="btn btn-end" onclick="endGame(${court.id})" style="margin-top: 5px;">End Game</button>
                    </div>` :
                    `<div class="assignment-buttons">
                        <button class="btn btn-assign" onclick="assignPlayers(${court.id})" ${!canAssignPlayers(court.id) ? 'disabled' : ''}>
                            üé≤ Auto Assign
                        </button>
                        <button class="btn btn-manual" onclick="openManualAssignment(${court.id})" ${!canAssignPlayers(court.id) ? 'disabled' : ''}>
                            üë• Manual Select
                        </button>
                        ${!canAssignPlayers(court.id) ? '<div style="text-align: center; font-size: 0.8em; color: #666; margin-top: 8px;">Need 4 checked-in players</div>' : ''}
                    </div>`
                }
                <div class="queue-info">${queueInfo}</div>
            `;

            return div;
        }

        // Get queue info for a court
        function getQueueInfo(court) {
            return ''; // Queue info removed per user request
        }

        // Check if we can assign players (court-specific logic)
        function canAssignPlayers(courtId = null) {
            const availableIntermediate = players.intermediate.filter(p => p.status === 'available' && p.checkedIn).length;
            const availableBeginner = players.beginner.filter(p => p.status === 'available' && p.checkedIn).length;
            
            // All courts can use either level
            // Also allow mixed games when individual levels don't have 4 players
            return availableIntermediate >= 4 || availableBeginner >= 4 || 
                   (availableIntermediate + availableBeginner >= 4);
        }

        // Get players based on queue priority (first-come, first-served)
        function getRandomPlayers(playersList, count) {
            // Sort players by queue time (oldest first) - this is the fair queue system
            const sortedByQueue = [...playersList].sort((a, b) => a.queueTimestamp - b.queueTimestamp);
            
            // Select the first 'count' players from the queue
            const selectedPlayers = sortedByQueue.slice(0, count);
            
            console.log(`Selected players: ${selectedPlayers.map(p => p.name).join(', ')}`);
            
            return selectedPlayers;
        }

        // End game on a court
        function endGame(courtId) {
            const court = courts.find(c => c.id === courtId);
            if (!court.occupied) return;

            // Get final time and stop the timer
            const finalTime = stopCourtTimer(courtId);
            const gameTimeFormatted = formatTime(finalTime);

            console.log(`=== GAME ENDING ON COURT ${courtId} ===`);
            console.log(`Players finishing: ${court.players.map(p => p.name).join(', ')}`);

            // Record game in history
            const gameRecord = {
                id: `game_${Date.now()}`,
                courtId: courtId,
                players: court.players.map(p => ({ name: p.name, level: p.level })),
                duration: finalTime,
                startTime: court.startTime ? court.startTime - (court.elapsedTime || 0) : Date.now() - finalTime,
                endTime: Date.now(),
                timestamp: Date.now()
            };
            
            gameHistory.unshift(gameRecord); // Add to beginning of array
            
            // Keep only last 50 games to prevent memory issues
            if (gameHistory.length > 50) {
                gameHistory = gameHistory.slice(0, 50);
            }

            // Update session statistics
            sessionStats.totalGames++;
            sessionStats.totalPlayTime += finalTime;
            sessionStats.averageGameDuration = sessionStats.totalPlayTime / sessionStats.totalGames;

            // Update player statistics
            court.players.forEach(player => {
                if (!playerStats[player.name]) {
                    playerStats[player.name] = {
                        gamesPlayed: 0,
                        totalPlayTime: 0,
                        averageGameDuration: 0,
                        lastPlayed: null,
                        level: player.level
                    };
                }
                
                const stats = playerStats[player.name];
                stats.gamesPlayed++;
                stats.totalPlayTime += finalTime;
                stats.averageGameDuration = stats.totalPlayTime / stats.gamesPlayed;
                stats.lastPlayed = Date.now();
                stats.level = player.level; // Update level in case it changed
            });

            // Show game summary
            const playerNames = court.players.map(p => p.name).join(', ');
            const summaryMessage = `üè∏ Game Complete!\n\nCourt ${courtId}\nPlayers: ${playerNames}\nGame Duration: ${gameTimeFormatted}\n\nGreat game everyone! üéâ`;
            
            alert(summaryMessage);

            // Update player status back to available and put them at END of queue
            court.players.forEach(player => {
                player.status = 'available';
                player.checkedIn = false; // Players are checked out after playing
                player.queueTimestamp = Date.now(); // New timestamp puts them at end of queue
                console.log(`${player.name} moved to end of queue with timestamp: ${player.queueTimestamp}`);
            });

            // Clear court
            court.occupied = false;
            court.players = [];

            renderPlayers();
            renderCourts();
            updateStats();
            updateStatsDashboard(); // Update statistics after game ends
            updateWaitTimes(); // Update wait times after game ends
            
            // Sync court end game to Firebase
            console.log('üè∏ Syncing court end game to Firebase');
            savePlayersDataWithSync();

            // Auto-assign next match if players are waiting
            setTimeout(() => {
                if (canAssignPlayers()) {
                    // You can uncomment this to auto-assign
                    // assignPlayers(courtId);
                }
            }, 500);
        }

        // Clear all data and reset to defaults
        function clearAllData() {
            const confirmClear = confirm('‚ö†Ô∏è This will reset attendance, game history, and statistics, but keep your custom player names. Continue?');
            if (confirmClear) {
                // Preserve current player names and custom players
                const currentPlayers = {
                    intermediate: [...players.intermediate],
                    beginner: [...players.beginner]
                };
                
                // Clear localStorage
                localStorage.removeItem('badmintonClubData');
                console.log('üóëÔ∏è Cleared saved data');
                
                // Reset attendance for all players
                currentPlayers.intermediate.forEach(player => {
                    player.status = 'available';
                    player.queueTimestamp = Date.now();
                });
                currentPlayers.beginner.forEach(player => {
                    player.status = 'available';
                    player.queueTimestamp = Date.now();
                });
                
                // Restore players with reset attendance
                players.intermediate = currentPlayers.intermediate;
                players.beginner = currentPlayers.beginner;
                
                // Reset courts
                courts.forEach(court => {
                    court.occupied = false;
                    court.players = [];
                    court.startTime = null;
                    court.elapsedTime = 0;
                });
                
                // Reset statistics
                gameHistory = [];
                playerStats = {};
                sessionStats = {
                    startTime: Date.now(),
                    totalGames: 0,
                    totalPlayTime: 0,
                    averageGameDuration: 0
                };
                
                // Stop any running timers
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
                
                // Update UI
                renderPlayers();
                renderCourts();
                updateStats();
                updateStatsDashboard();
                
                // Save the reset data
                savePlayersDataWithSync();
                
                alert('‚úÖ Attendance and statistics reset! Your custom player names have been preserved.');
            }
        }

        // Clear browser cache and localStorage
        function clearCache() {
            if (confirm('‚ö†Ô∏è This will clear all cached data and refresh the page. Continue?')) {
                try {
                    // Clear localStorage
                    localStorage.clear();
                    
                    // Clear sessionStorage
                    sessionStorage.clear();
                    
                    // Clear service worker cache if available
                    if ('serviceWorker' in navigator && 'caches' in window) {
                        caches.keys().then(function(cacheNames) {
                            return Promise.all(
                                cacheNames.map(function(cacheName) {
                                    return caches.delete(cacheName);
                                })
                            );
                        });
                    }
                    
                    console.log('üßπ Cache cleared successfully');
                    alert('‚úÖ Cache cleared! Page will refresh.');
                    
                    // Force refresh without cache
                    window.location.reload(true);
                    
                } catch (error) {
                    console.error('‚ùå Error clearing cache:', error);
                    alert('‚ùå Error clearing cache. Try manually clearing browser data.');
                }
            }
        }

        // Fix Firebase data structure
        function fixFirebaseData() {
            if (!isFirebaseConnected) {
                alert('‚ùå Firebase not connected. Cannot fix data.');
                return;
            }

            const confirmFix = confirm('üîß This will clear corrupted Firebase data and upload fresh player data. Continue?');
            if (confirmFix) {
                console.log('üîß Fixing Firebase data structure...');
                
                // Clear corrupted Firebase data first
                database.ref('badmintonClub').remove()
                    .then(() => {
                        console.log('üóëÔ∏è Cleared corrupted Firebase data');
                        
                        // Reset local data to defaults
                        players.intermediate = [];
                        players.beginner = [];
                        
                        // Initialize with fresh default data
                        initializePlayers();
                        
                        alert('‚úÖ Firebase data fixed! Try renaming a player now.');
                    })
                    .catch((error) => {
                        console.error('‚ùå Failed to clear Firebase data:', error);
                        alert('‚ùå Failed to fix Firebase data: ' + error.message);
                    });
            }
        }

        // Update statistics
        function updateStats() {
            const totalPresent = players.intermediate.filter(p => p.status !== 'absent').length + 
                               players.beginner.filter(p => p.status !== 'absent').length;
            const activeGames = courts.filter(c => c.occupied).length;
            const availableCourts = courts.filter(c => !c.occupied).length;

            document.getElementById('totalPlayers').textContent = totalPresent + ' present';
            document.getElementById('activeGames').textContent = activeGames;
            document.getElementById('availableCourts').textContent = availableCourts;
        }

        // Firebase Configuration and Real-time Database Integration
        let firebaseApp = null;
        let database = null;
        let isFirebaseConnected = false;
        let isInitializing = true;
        let currentUserId = 'user-' + Math.random().toString(36).substr(2, 9); // Unique user ID for this session

        // Firebase configuration - Shingw√†kons PS Badminton Club
        const firebaseConfig = {
            apiKey: "AIzaSyCcW9gyRlIDGxLdqNIt5hZN5pQOzsjWSsU",
            authDomain: "shingwakons-badminton-club.firebaseapp.com",
            databaseURL: "https://shingwakons-badminton-club-default-rtdb.firebaseio.com/",
            projectId: "shingwakons-badminton-club",
            storageBucket: "shingwakons-badminton-club.firebasestorage.app",
            messagingSenderId: "37974035469",
            appId: "1:37974035469:web:f8809c731372c5da005944"
        };

        // Initialize Firebase
        function initializeFirebase() {
            try {
                // Check if config has been updated from placeholder
                if (firebaseConfig.apiKey === "YOUR_API_KEY_HERE") {
                    console.log('üîß Firebase not configured yet - using localStorage only');
                    console.log('üìã See FIREBASE-SETUP-GUIDE.md for setup instructions');
                    isFirebaseConnected = false;
                    return false;
                }

                firebaseApp = firebase.initializeApp(firebaseConfig);
                database = firebase.database();
                
                // Test connection
                database.ref('.info/connected').on('value', (snapshot) => {
                    if (snapshot.val() === true) {
                        isFirebaseConnected = true;
                        console.log('‚úÖ Firebase connected - real-time sync enabled');
                        showConnectionStatus('üåê Live sync enabled');
                        
                        // Load data from Firebase on first connection
                        if (isInitializing) {
                            loadDataFromFirebase();
                        }
                    } else {
                        isFirebaseConnected = false;
                        console.log('‚ùå Firebase disconnected - using localStorage backup');
                        showConnectionStatus('üì± Offline mode');
                    }
                });

                // Listen for real-time data changes
                database.ref('badmintonClub').on('value', (snapshot) => {
                    if (!isInitializing && snapshot.exists()) {
                        const firebaseData = snapshot.val();
                        if (firebaseData && firebaseData.players) {
                            // Only update if this change came from another user
                            if (firebaseData.updatedBy !== currentUserId) {
                                console.log('üîÑ Received real-time update from another user');
                                console.log('üìä Firebase data:', firebaseData);
                                
                                // Check if courts changed
                                const courtsChanged = firebaseData.courts && 
                                    JSON.stringify(firebaseData.courts) !== JSON.stringify(courts);
                                
                                updateLocalDataFromFirebase(firebaseData);
                                
                                if (courtsChanged) {
                                    showConnectionStatus('üè∏ Courts updated');
                                } else {
                                    showConnectionStatus('üîÑ Data updated');
                                }
                            } else {
                                console.log('üìù Ignoring own update');
                            }
                        }
                    }
                });

                return true;
            } catch (error) {
                console.error('‚ùå Firebase initialization failed:', error);
                isFirebaseConnected = false;
                return false;
            }
        }

        // Show connection status to users
        function showConnectionStatus(message) {
            // Remove existing status
            const existingStatus = document.getElementById('connection-status');
            if (existingStatus) existingStatus.remove();

            // Create status indicator
            const statusDiv = document.createElement('div');
            statusDiv.id = 'connection-status';
            statusDiv.style.cssText = `
                position: fixed;
                top: 60px;
                right: 20px;
                background: ${isFirebaseConnected ? '#4caf50' : '#ff9800'};
                color: white;
                padding: 8px 15px;
                border-radius: 20px;
                font-size: 12px;
                z-index: 999;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                transition: all 0.3s ease;
            `;
            statusDiv.textContent = message;
            document.body.appendChild(statusDiv);

            // Auto-hide after 3 seconds
            setTimeout(() => {
                if (statusDiv.parentNode) {
                    statusDiv.style.opacity = '0';
                    setTimeout(() => statusDiv.remove(), 300);
                }
            }, 3000);
        }

        // Save data to Firebase (with localStorage fallback)
        function saveDataToFirebase() {
            const dataToSave = {
                players: players,
                courts: courts, // Add courts to Firebase sync
                gameHistory: gameHistory,
                playerStats: playerStats,
                sessionStats: sessionStats,
                gameSettings: gameSettings,
                lastUpdated: Date.now(),
                updatedBy: currentUserId
            };

            console.log('üíæ Attempting to save data...');

            // Always save to localStorage as backup
            savePlayersData();

            // Try to save to Firebase if connected
            if (isFirebaseConnected && database) {
                try {
                    database.ref('badmintonClub').set(dataToSave)
                        .then(() => {
                            console.log('‚úÖ Data successfully synced to Firebase');
                            showConnectionStatus('‚úÖ Data synced');
                        })
                        .catch((error) => {
                            console.error('‚ùå Firebase save failed:', error);
                            console.error('Error details:', error.code, error.message);
                            showConnectionStatus('‚ùå Sync failed');
                            alert('Firebase save failed: ' + error.message);
                        });
                } catch (error) {
                    console.error('‚ùå Firebase save error:', error);
                    showConnectionStatus('‚ùå Sync error');
                }
            } else {
                showConnectionStatus('üì± Offline mode');
            }
        }

        // Load data from Firebase
        function loadDataFromFirebase() {
            if (!isFirebaseConnected || !database) {
                console.log('üìÇ Loading from localStorage (Firebase not available)');
                return;
            }

            console.log('üìÇ Attempting to load data from Firebase...');
            database.ref('badmintonClub').once('value')
                .then((snapshot) => {
                    console.log('üìä Firebase snapshot received:', snapshot.exists());
                    
                    if (snapshot.exists()) {
                        const firebaseData = snapshot.val();
                        console.log('üìä Raw Firebase data:', firebaseData);
                        
                        if (firebaseData && firebaseData.players) {
                            console.log('üìÇ Valid Firebase data found, loading...');
                            updateLocalDataFromFirebase(firebaseData);
                        } else {
                            console.log('‚ö†Ô∏è Firebase data exists but no valid players structure');
                            // Initialize with default data and save to Firebase
                            initializePlayers();
                        }
                    } else {
                        console.log('üìÇ No Firebase data exists, initializing defaults');
                        // No Firebase data, initialize with defaults
                        initializePlayers();
                    }
                    
                    isInitializing = false;
                })
                .catch((error) => {
                    console.error('‚ùå Firebase load failed:', error);
                    console.log('üìÇ Falling back to localStorage/defaults');
                    initializePlayers();
                    isInitializing = false;
                });
        }

        // Update local data from Firebase
        function updateLocalDataFromFirebase(firebaseData) {
            console.log('üîÑ updateLocalDataFromFirebase called with:', firebaseData);
            
            if (firebaseData && firebaseData.players) {
                console.log('üìä Firebase players data:', firebaseData.players);
                
                // Ensure players object has the correct structure
                if (firebaseData.players.intermediate && firebaseData.players.beginner) {
                    players = firebaseData.players;
                    
                    // Load statistics data from Firebase
                    if (firebaseData.gameHistory) {
                        gameHistory = firebaseData.gameHistory;
                        console.log('‚úÖ Loaded game history from Firebase');
                    }
                    
                    if (firebaseData.playerStats) {
                        playerStats = firebaseData.playerStats;
                        console.log('‚úÖ Loaded player stats from Firebase');
                    }
                    
                    if (firebaseData.sessionStats) {
                        sessionStats = { ...sessionStats, ...firebaseData.sessionStats };
                        // Reset session start time to current session
                        sessionStats.startTime = Date.now();
                        console.log('‚úÖ Loaded session stats from Firebase');
                    }
                    
                    if (firebaseData.gameSettings) {
                        gameSettings = { ...gameSettings, ...firebaseData.gameSettings };
                        console.log('‚úÖ Loaded game settings from Firebase');
                        
                        // Update the UI input
                        setTimeout(() => {
                            const input = document.getElementById('avgGameDurationSetting');
                            if (input) {
                                input.value = Math.round(gameSettings.defaultGameDuration / (60 * 1000));
                            }
                        }, 100);
                    }
                    
                    // Update courts from Firebase if available
                    if (firebaseData.courts && Array.isArray(firebaseData.courts)) {
                        console.log('üè∏ Syncing court data from Firebase');
                        courts = firebaseData.courts;
                    } else {
                        console.log('üè∏ No court data in Firebase, keeping local courts');
                    // Reset courts if not in Firebase (don't persist games across sessions)
                    courts.forEach(court => {
                        court.occupied = false;
                        court.players = [];
                        court.startTime = null;
                        court.elapsedTime = 0;
                    });
                    
                    // Stop any running timers
                    if (timerInterval) {
                        clearInterval(timerInterval);
                        timerInterval = null;
                    }
                    }
                    
                    // Reset playing status if courts are empty (consistency check)
                    const anyOccupiedCourt = courts.some(court => court.occupied);
                    if (!anyOccupiedCourt) {
                        // No active games, ensure all players are available
                        players.intermediate.forEach(player => {
                            if (player.status === 'playing') {
                                player.status = 'available';
                            }
                        });
                        players.beginner.forEach(player => {
                            if (player.status === 'playing') {
                                player.status = 'available';
                            }
                        });
                    }
                    
                    console.log('‚úÖ Successfully updated local data from Firebase');
                    
                    // Update UI
                    renderPlayers();
                    renderCourts();
                    updateStats();
                    
                    // Save to localStorage as backup
                    savePlayersData();
                } else {
                    console.error('‚ùå Invalid Firebase data structure:', firebaseData.players);
                }
            } else {
                console.log('‚ö†Ô∏è No valid players data in Firebase response');
            }
        }

        // Calculate smart wait time for a player based on actual wait duration and queue position
        function calculateWaitTime(player) {
            const availableIntermediate = players.intermediate.filter(p => p.status === 'available');
            const availableBeginner = players.beginner.filter(p => p.status === 'available');
            const allAvailable = [...availableIntermediate, ...availableBeginner];
            
            // Sort by queue timestamp to get position (earliest timestamp = longest wait = higher priority)
            const sortedQueue = allAvailable.sort((a, b) => a.queueTimestamp - b.queueTimestamp);
            const playerPosition = sortedQueue.findIndex(p => p.id === player.id) + 1;
            
            if (playerPosition === 0) return { position: 0, estimate: '0 min', actualWait: '0 min', class: 'short' };
            
            // Calculate actual time this player has been waiting
            const actualWaitMs = Date.now() - player.queueTimestamp;
            const actualWaitMinutes = Math.floor(actualWaitMs / (60 * 1000));
            const actualWaitText = actualWaitMinutes < 1 ? '< 1 min' : `${actualWaitMinutes} min`;
            
            const occupiedCourts = courts.filter(c => c.occupied).length;
            const availableCourts = courts.length - occupiedCourts;
            
            // If courts are available, player could be assigned immediately
            if (availableCourts > 0 && playerPosition <= availableCourts * 4) {
                return { 
                    position: playerPosition, 
                    estimate: 'Next up!', 
                    actualWait: actualWaitText,
                    class: 'short' 
                };
            }
            
            // Smart estimation based on:
            // 1. Current games in progress and their elapsed time
            // 2. Queue position ahead of this player
            // 3. Average game duration (session or custom setting)
            
            const avgGameDuration = sessionStats.averageGameDuration || gameSettings.defaultGameDuration;
            
            // Calculate estimated time until courts become available
            let minTimeToCourtAvailable = Infinity;
            
            courts.forEach(court => {
                if (court.occupied && court.startTime) {
                    const gameElapsed = Date.now() - court.startTime;
                    const estimatedTimeLeft = Math.max(0, avgGameDuration - gameElapsed);
                    minTimeToCourtAvailable = Math.min(minTimeToCourtAvailable, estimatedTimeLeft);
                } else if (court.occupied && court.elapsedTime) {
                    const estimatedTimeLeft = Math.max(0, avgGameDuration - court.elapsedTime);
                    minTimeToCourtAvailable = Math.min(minTimeToCourtAvailable, estimatedTimeLeft);
                }
            });
            
            // If no courts are occupied, use average game duration
            if (minTimeToCourtAvailable === Infinity) {
                minTimeToCourtAvailable = avgGameDuration;
            }
            
            // Calculate how many "waves" of players are ahead
            const playersAhead = playerPosition - 1;
            const wavesAhead = Math.floor(playersAhead / 4); // 4 players per wave
            const extraWaitTime = wavesAhead * avgGameDuration;
            
            const totalEstimatedWaitMs = minTimeToCourtAvailable + extraWaitTime;
            const estimatedMinutes = Math.ceil(totalEstimatedWaitMs / (60 * 1000));
            
            let estimate, cssClass;
            if (estimatedMinutes <= 5) {
                estimate = `${estimatedMinutes} min`;
                cssClass = 'short';
            } else if (estimatedMinutes <= 15) {
                estimate = `${estimatedMinutes} min`;
                cssClass = 'medium';
            } else {
                estimate = `${estimatedMinutes} min`;
                cssClass = 'long';
            }
            
            return { 
                position: playerPosition, 
                estimate: estimate, 
                actualWait: actualWaitText,
                class: cssClass 
            };
        }

        // Update statistics dashboard
        function updateStatsDashboard() {
            // Update session overview
            document.getElementById('totalGamesCompleted').textContent = sessionStats.totalGames;
            document.getElementById('totalPlayTime').textContent = formatTime(sessionStats.totalPlayTime);
            document.getElementById('avgGameDuration').textContent = formatTime(sessionStats.averageGameDuration);
            
            const sessionDuration = Date.now() - sessionStats.startTime;
            document.getElementById('sessionDuration').textContent = formatTime(sessionDuration);
            
            // Update court utilization
            updateCourtUtilization();
            
            // Update player statistics
            updatePlayerStatistics();
            
            // Update recent games
            updateRecentGames();
            
            // Update wait times
            updateWaitTimes();
        }

        // Update court utilization display
        function updateCourtUtilization() {
            const container = document.getElementById('courtUtilization');
            const sessionDuration = Date.now() - sessionStats.startTime;
            
            let html = '';
            courts.forEach(court => {
                let usageTime = 0;
                
                // Calculate usage time for this court
                gameHistory.forEach(game => {
                    if (game.courtId === court.id) {
                        usageTime += game.duration;
                    }
                });
                
                // Add current game time if court is occupied
                if (court.occupied && court.startTime) {
                    usageTime += Date.now() - court.startTime;
                } else if (court.occupied && court.elapsedTime) {
                    usageTime += court.elapsedTime;
                }
                
                const usagePercent = sessionDuration > 0 ? Math.round((usageTime / sessionDuration) * 100) : 0;
                
                html += `
                    <div class="court-usage-bar">
                        <div class="court-usage-label">Court ${court.id}</div>
                        <div class="court-usage-progress">
                            <div class="court-usage-fill" style="width: ${Math.min(usagePercent, 100)}%"></div>
                        </div>
                        <div class="court-usage-percent">${usagePercent}%</div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        // Update player statistics display
        function updatePlayerStatistics() {
            const container = document.getElementById('playerStatsContainer');
            const filter = document.getElementById('playerStatsFilter').value;
            
            // Get filtered player stats
            let filteredStats = Object.entries(playerStats);
            
            if (filter === 'intermediate') {
                filteredStats = filteredStats.filter(([name, stats]) => stats.level === 'intermediate');
            } else if (filter === 'beginner') {
                filteredStats = filteredStats.filter(([name, stats]) => stats.level === 'beginner');
            }
            
            // Sort by games played (descending)
            filteredStats.sort((a, b) => b[1].gamesPlayed - a[1].gamesPlayed);
            
            let html = '';
            if (filteredStats.length === 0) {
                html = '<div style="text-align: center; color: #6c757d; padding: 20px;">No games played yet</div>';
            } else {
                filteredStats.slice(0, 10).forEach(([name, stats]) => {
                    html += `
                        <div class="player-stat-row">
                            <div class="player-stat-name">${name}</div>
                            <div class="player-stat-value">${stats.gamesPlayed} games (${formatTime(stats.averageGameDuration)} avg)</div>
                        </div>
                    `;
                });
            }
            
            container.innerHTML = html;
        }

        // Update recent games display
        function updateRecentGames() {
            const container = document.getElementById('recentGamesContainer');
            
            let html = '';
            if (gameHistory.length === 0) {
                html = '<div style="text-align: center; color: #6c757d; padding: 20px;">No games completed yet</div>';
            } else {
                gameHistory.slice(0, 5).forEach(game => {
                    const timeAgo = Math.floor((Date.now() - game.timestamp) / (60 * 1000));
                    const timeAgoText = timeAgo < 1 ? 'Just now' : `${timeAgo} min ago`;
                    
                    html += `
                        <div class="recent-game-item">
                            <div class="recent-game-info">
                                <div class="recent-game-court">Court ${game.courtId} - ${timeAgoText}</div>
                                <div class="recent-game-players">${game.players.map(p => p.name).join(', ')}</div>
                            </div>
                            <div class="recent-game-duration">${formatTime(game.duration)}</div>
                        </div>
                    `;
                });
            }
            
            container.innerHTML = html;
        }

        // Update current queue display
        function updateWaitTimes() {
            const container = document.getElementById('waitTimeContainer');
            
            const availableIntermediate = players.intermediate.filter(p => p.status === 'available' && p.checkedIn);
            const availableBeginner = players.beginner.filter(p => p.status === 'available' && p.checkedIn);
            const allAvailable = [...availableIntermediate, ...availableBeginner];
            
            if (allAvailable.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #6c757d; padding: 20px;">No players checked in</div>';
                return;
            }
            
            // Sort by queue timestamp (earliest = highest priority)
            const sortedQueue = allAvailable.sort((a, b) => a.queueTimestamp - b.queueTimestamp);
            
            let html = '';
            sortedQueue.forEach((player, index) => {
                const position = index + 1;
                
                html += `
                    <div class="wait-time-item">
                        <div class="wait-time-player">
                            <div class="wait-time-position">${position}</div>
                            <span>${player.name} (${player.level})</span>
                        </div>
                        <div class="queue-status">
                            ${position <= 4 ? '<span style="color: #28a745; font-weight: bold;">Next up!</span>' : 'In queue'}
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        // Update game duration setting
        function updateGameDurationSetting() {
            const input = document.getElementById('avgGameDurationSetting');
            const minutes = parseInt(input.value);
            
            if (minutes >= 5 && minutes <= 60) {
                gameSettings.defaultGameDuration = minutes * 60 * 1000; // Convert to milliseconds
                console.log(`‚öôÔ∏è Game duration setting updated to ${minutes} minutes`);
                
                // Update wait times immediately
                updateWaitTimes();
                
                // Save settings
                savePlayersDataWithSync();
                
                // Show feedback
                showConnectionStatus(`‚öôÔ∏è Game duration set to ${minutes} min`);
            } else {
                alert('Please enter a duration between 5 and 60 minutes');
                input.value = Math.round(gameSettings.defaultGameDuration / (60 * 1000)); // Reset to current value
            }
        }

        // Load game settings from saved data
        function loadGameSettings() {
            const savedData = localStorage.getItem('badmintonClubData');
            if (savedData) {
                try {
                    const parsedData = JSON.parse(savedData);
                    if (parsedData.gameSettings) {
                        gameSettings = { ...gameSettings, ...parsedData.gameSettings };
                        
                        // Update the UI input
                        const input = document.getElementById('avgGameDurationSetting');
                        if (input) {
                            input.value = Math.round(gameSettings.defaultGameDuration / (60 * 1000));
                        }
                        
                        console.log('‚úÖ Loaded game settings');
                    }
                } catch (error) {
                    console.error('‚ùå Error loading game settings:', error);
                }
            }
        }

        // Start wait time auto-update timer
        function startWaitTimeUpdates() {
            if (!waitTimeUpdateInterval) {
                waitTimeUpdateInterval = setInterval(() => {
                    // Only update if stats section is active or wait times are visible
                    const statsSection = document.getElementById('statsSection');
                    if (statsSection && statsSection.classList.contains('active')) {
                        updateWaitTimes();
                    }
                }, 30000); // Update every 30 seconds
                console.log('‚è∞ Started wait time auto-updates');
            }
        }

        // Stop wait time auto-update timer
        function stopWaitTimeUpdates() {
            if (waitTimeUpdateInterval) {
                clearInterval(waitTimeUpdateInterval);
                waitTimeUpdateInterval = null;
                console.log('‚è∞ Stopped wait time auto-updates');
            }
        }

        // Enhanced tab switching with wait time updates
        function switchTab(tab) {
            const playersSection = document.getElementById('playersSection');
            const courtsSection = document.getElementById('courtsSection');
            const statsSection = document.getElementById('statsSection');
            const tabButtons = document.querySelectorAll('.tab-btn');

            // Remove active class from all sections and buttons
            playersSection.classList.remove('active');
            courtsSection.classList.remove('active');
            statsSection.classList.remove('active');
            tabButtons.forEach(btn => btn.classList.remove('active'));

            if (tab === 'players') {
                playersSection.classList.add('active');
                tabButtons[0].classList.add('active');
                stopWaitTimeUpdates();
            } else if (tab === 'courts') {
                courtsSection.classList.add('active');
                tabButtons[1].classList.add('active');
                stopWaitTimeUpdates();
            } else if (tab === 'stats') {
                statsSection.classList.add('active');
                tabButtons[2].classList.add('active');
                updateStatsDashboard(); // Refresh stats when switching to stats tab
                startWaitTimeUpdates(); // Start auto-updating wait times
            }
        }

        // Add event listener for player stats filter
        document.addEventListener('DOMContentLoaded', function() {
            const filterSelect = document.getElementById('playerStatsFilter');
            if (filterSelect) {
                filterSelect.addEventListener('change', updatePlayerStatistics);
            }
            
            // Load game settings when page loads
            setTimeout(loadGameSettings, 100);
            
            // Start wait time updates if stats section is initially active
            setTimeout(() => {
                const statsSection = document.getElementById('statsSection');
                if (statsSection && statsSection.classList.contains('active')) {
                    startWaitTimeUpdates();
                }
            }, 1000);
        });

        // Modified save function that uses Firebase
        function savePlayersDataWithSync() {
            console.log('üîÑ savePlayersDataWithSync called');
            console.log('üî• Firebase connected status:', isFirebaseConnected);
            console.log('üìä Current players data:', players);
            
            if (isFirebaseConnected) {
                console.log('‚úÖ Using Firebase sync');
                saveDataToFirebase();
            } else {
                console.log('üì± Using localStorage only (Firebase not connected)');
                savePlayersData(); // Fallback to localStorage only
            }
        }

        // Initialize the app
        console.log('üöÄ Initializing Badminton Court Manager...');
        
        // Initialize Firebase first
        console.log('üî• Starting Firebase initialization...');
        const firebaseInitResult = initializeFirebase();
        console.log('üî• Firebase init result:', firebaseInitResult);
        
        // Initialize players (will load from Firebase if available, otherwise localStorage/defaults)
        setTimeout(() => {
            if (!isFirebaseConnected) {
                initializePlayers();
                isInitializing = false;
            }
        }, 1000); // Give Firebase a moment to connect

        // PWA Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then((registration) => {
                        console.log('PWA: Service Worker registered successfully:', registration.scope);
                        
                        // Check for updates
                        registration.addEventListener('updatefound', () => {
                            console.log('PWA: New version available');
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // New content is available, show update notification
                                    if (confirm('New version available! Refresh to update?')) {
                                        window.location.reload();
                                    }
                                }
                            });
                        });
                    })
                    .catch((error) => {
                        console.log('PWA: Service Worker registration failed:', error);
                    });
            });
        }

        // PWA Install Prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            console.log('PWA: Install prompt available');
            e.preventDefault();
            deferredPrompt = e;
            
            // Show install button or notification
            showInstallPrompt();
        });

        function showInstallPrompt() {
            // Create install notification
            const installBanner = document.createElement('div');
            installBanner.id = 'install-banner';
            installBanner.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                background: #4caf50;
                color: white;
                padding: 10px 20px;
                border-radius: 25px;
                font-size: 14px;
                z-index: 1000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                cursor: pointer;
                animation: slideDown 0.3s ease;
            `;
            installBanner.innerHTML = 'üì± Install App - Tap here!';
            
            installBanner.addEventListener('click', async () => {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log('PWA: Install prompt result:', outcome);
                    deferredPrompt = null;
                    installBanner.remove();
                }
            });
            
            document.body.appendChild(installBanner);
            
            // Auto-hide after 10 seconds
            setTimeout(() => {
                if (installBanner.parentNode) {
                    installBanner.remove();
                }
            }, 10000);
        }

        // Add slide animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideDown {
                from { transform: translateX(-50%) translateY(-100%); }
                to { transform: translateX(-50%) translateY(0); }
            }
        `;
        document.head.appendChild(style);

        // PWA Installation Success
        window.addEventListener('appinstalled', (evt) => {
            console.log('PWA: App installed successfully');
            // Remove install prompt if still visible
            const installBanner = document.getElementById('install-banner');
            if (installBanner) {
                installBanner.remove();
            }
        });

        // Push notification functions
        let notificationPermission = false;

        // Request notification permission
        async function requestNotificationPermission() {
            if ('Notification' in window) {
                const permission = await Notification.requestPermission();
                notificationPermission = permission === 'granted';
                console.log('üîî Notification permission:', permission);
                
                if (notificationPermission) {
                    showConnectionStatus('üîî Notifications enabled');
                } else {
                    console.log('üîî Notifications denied or not supported');
                }
                
                return notificationPermission;
            }
            return false;
        }

        // Send push notification
        function sendNotification(title, body, data = {}) {
            if (notificationPermission && 'Notification' in window) {
                const notification = new Notification(title, {
                    body: body,
                    icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="50" font-size="50">üè∏</text></svg>',
                    badge: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="50" font-size="50">üè∏</text></svg>',
                    data: data,
                    requireInteraction: false,
                    tag: 'badminton-court'
                });

                notification.onclick = function() {
                    window.focus();
                    this.close();
                };

                // Auto close after 8 seconds
                setTimeout(() => notification.close(), 8000);
                
                console.log('üîî Notification sent:', title);
            }
        }

        // Send notification to all assigned players
        function checkForPlayerTurn(selectedPlayers) {
            if (selectedPlayers.length > 0) {
                const names = selectedPlayers.map(p => p.name).join(', ');
                sendNotification(
                    'üéØ Game Assignment!',
                    `Players assigned to court: ${names}`,
                    { type: 'player_turn', players: names }
                );
            }
        }

        // Initialize notifications when app loads
        window.addEventListener('load', () => {
            // Request notification permission after a short delay
            setTimeout(() => {
                if (!notificationPermission) {
                    requestNotificationPermission();
                }
            }, 2000);
        });

        // Manual Assignment Functions
        let currentCourtForManualAssignment = null;
        let selectedPlayersForManualAssignment = [];

        function openManualAssignment(courtId) {
            currentCourtForManualAssignment = courtId;
            selectedPlayersForManualAssignment = [];
            
            // Show modal
            document.getElementById('manualAssignmentModal').style.display = 'block';
            
            // Update modal title
            document.getElementById('modalCourtTitle').textContent = `Court ${courtId}`;
            
            // Render available players
            renderManualAssignmentPlayers();
            updateSelectedCount();
        }

        function closeManualAssignment() {
            document.getElementById('manualAssignmentModal').style.display = 'none';
            currentCourtForManualAssignment = null;
            selectedPlayersForManualAssignment = [];
        }

        function renderManualAssignmentPlayers() {
            const availableIntermediate = players.intermediate.filter(p => p.status === 'available' && p.checkedIn);
            const availableBeginner = players.beginner.filter(p => p.status === 'available' && p.checkedIn);
            const allAvailable = [...availableIntermediate, ...availableBeginner];

            const container = document.getElementById('playerSelectionContainer');
            container.innerHTML = '';

            if (allAvailable.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No players checked in for assignment</p>';
                return;
            }

            // Group by level for better organization
            if (availableIntermediate.length > 0) {
                const intermediateHeader = document.createElement('h4');
                intermediateHeader.textContent = `Intermediate Players (${availableIntermediate.length})`;
                intermediateHeader.style.cssText = 'color: #ff9800; margin: 15px 0 10px 0; text-align: center;';
                container.appendChild(intermediateHeader);

                availableIntermediate.forEach(player => {
                    container.appendChild(createPlayerOption(player));
                });
            }

            if (availableBeginner.length > 0) {
                const beginnerHeader = document.createElement('h4');
                beginnerHeader.textContent = `Beginner Players (${availableBeginner.length})`;
                beginnerHeader.style.cssText = 'color: #2196F3; margin: 15px 0 10px 0; text-align: center;';
                container.appendChild(beginnerHeader);

                availableBeginner.forEach(player => {
                    container.appendChild(createPlayerOption(player));
                });
            }
        }

        function createPlayerOption(player) {
            const div = document.createElement('div');
            div.className = `player-option ${player.level}`;
            div.textContent = player.name;
            div.onclick = () => togglePlayerSelection(player);
            return div;
        }

        function togglePlayerSelection(player) {
            const index = selectedPlayersForManualAssignment.findIndex(p => p.id === player.id);
            
            if (index === -1) {
                // Add player if not selected and we have room
                if (selectedPlayersForManualAssignment.length < 4) {
                    selectedPlayersForManualAssignment.push(player);
                } else {
                    alert('You can only select 4 players maximum for a court.');
                    return;
                }
            } else {
                // Remove player if already selected
                selectedPlayersForManualAssignment.splice(index, 1);
            }
            
            updatePlayerSelectionUI();
            updateSelectedCount();
        }

        function updatePlayerSelectionUI() {
            const playerOptions = document.querySelectorAll('.player-option');
            playerOptions.forEach(option => {
                const playerName = option.textContent;
                const isSelected = selectedPlayersForManualAssignment.some(p => p.name === playerName);
                
                if (isSelected) {
                    option.classList.add('selected');
                } else {
                    option.classList.remove('selected');
                }
            });
        }

        function updateSelectedCount() {
            const countElement = document.getElementById('selectedCount');
            const count = selectedPlayersForManualAssignment.length;
            countElement.textContent = `Selected: ${count}/4 players`;
            
            // Update assign button state
            const assignBtn = document.getElementById('manualAssignBtn');
            assignBtn.disabled = count !== 4;
            
            if (count === 4) {
                assignBtn.style.opacity = '1';
                assignBtn.style.cursor = 'pointer';
            } else {
                assignBtn.style.opacity = '0.6';
                assignBtn.style.cursor = 'not-allowed';
            }
        }

        function confirmManualAssignment() {
            if (selectedPlayersForManualAssignment.length !== 4) {
                alert('Please select exactly 4 players.');
                return;
            }

            const court = courts.find(c => c.id === currentCourtForManualAssignment);
            if (!court || court.occupied) {
                alert('Court is not available for assignment.');
                return;
            }

            // Update player status
            selectedPlayersForManualAssignment.forEach(player => {
                if (player.level === 'intermediate') {
                    const playerIndex = players.intermediate.findIndex(p => p.id === player.id);
                    if (playerIndex !== -1) {
                        players.intermediate[playerIndex].status = 'playing';
                    }
                } else {
                    const playerIndex = players.beginner.findIndex(p => p.id === player.id);
                    if (playerIndex !== -1) {
                        players.beginner[playerIndex].status = 'playing';
                    }
                }
            });

            // Update court
            court.occupied = true;
            court.players = selectedPlayersForManualAssignment;

            // Start the timer for this court
            startCourtTimer(currentCourtForManualAssignment);

            // Log the manual assignment
            console.log(`Court ${currentCourtForManualAssignment} (Manual Assignment): Selected players - ${selectedPlayersForManualAssignment.map(p => `${p.name}(${p.level})`).join(', ')}`);

            // Update UI
            renderPlayers();
            renderCourts();
            updateStats();
            
            // Send push notifications
            checkForPlayerTurn(selectedPlayersForManualAssignment);
            
            // Voice announcement
            const playerNames = selectedPlayersForManualAssignment.map(p => p.name);
            announcePlayerNames(playerNames);
            
            // Sync to Firebase
            console.log('üè∏ Syncing manual court assignment to Firebase');
            savePlayersDataWithSync();

            // Close modal
            closeManualAssignment();

            // Switch to courts tab on mobile after assigning
            if (isMobile()) {
                setTimeout(() => switchTab('courts'), 100);
            }
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('manualAssignmentModal');
            if (event.target === modal) {
                closeManualAssignment();
            }
        }
    </script>

    <!-- Manual Assignment Modal -->
    <div id="manualAssignmentModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Manual Player Assignment - <span id="modalCourtTitle">Court</span></h2>
                <span class="close" onclick="closeManualAssignment()">&times;</span>
            </div>
            
            <div class="selected-count" id="selectedCount">Selected: 0/4 players</div>
            
            <div id="playerSelectionContainer" class="player-selection">
                <!-- Players will be populated here -->
            </div>
            
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-primary" id="manualAssignBtn" onclick="confirmManualAssignment()" disabled>
                    ‚úÖ Assign Selected Players
                </button>
                <button class="modal-btn modal-btn-secondary" onclick="closeManualAssignment()">
                    ‚ùå Cancel
                </button>
            </div>
        </div>
    </div>
</body>
</html>