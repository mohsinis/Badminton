<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shingw√†kons PS Badminton Club</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="Court management system for Shingw√†kons PS Badminton Club">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Badminton Club">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Badminton Club">
    
    <!-- PWA Icons for iOS -->
    <link rel="apple-touch-icon" sizes="180x180" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='40' fill='%23667eea'/%3E%3Ctext x='50' y='60' font-size='40' text-anchor='middle' fill='white'%3Eüè∏%3C/text%3E%3C/svg%3E">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='40' fill='%23667eea'/%3E%3Ctext x='50' y='60' font-size='40' text-anchor='middle' fill='white'%3Eüè∏%3C/text%3E%3C/svg%3E">
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 1.8em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat-card {
            background: rgba(255,255,255,0.2);
            padding: 10px 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            color: white;
            font-size: 0.9em;
            flex: 1;
            min-width: 100px;
            text-align: center;
        }

        .mobile-tabs {
            display: none;
            background: white;
            border-radius: 10px;
            margin-bottom: 15px;
            overflow: hidden;
        }

        .tab-buttons {
            display: flex;
            width: 100%;
        }

        .tab-btn {
            flex: 1;
            padding: 12px;
            border: none;
            background: #f5f5f5;
            color: #666;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .tab-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        @media (max-width: 768px) {
            body {
                padding: 5px;
            }

            .header h1 {
                font-size: 1.5em;
            }

            .stats {
                gap: 5px;
            }

            .stat-card {
                padding: 8px 10px;
                font-size: 0.8em;
            }

            .mobile-tabs {
                display: block;
            }

            .main-content {
                grid-template-columns: 1fr;
            }

            .players-section {
                display: none;
            }

            .players-section.active {
                display: block;
            }

            .courts-section {
                display: none;
            }

            .courts-section.active {
                display: grid;
            }
        }

        .players-section {
            background: white;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            max-height: 600px;
            overflow-y: auto;
        }

        @media (max-width: 768px) {
            .players-section {
                max-height: calc(100vh - 250px);
                padding: 12px;
            }
        }

        .players-section h2 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.3em;
        }

        .player-group {
            margin-bottom: 20px;
        }

        .player-group h3 {
            color: #666;
            margin-bottom: 10px;
            font-size: 1em;
        }

        .player-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .player-item {
            padding: 8px 10px;
            background: #f5f5f5;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            font-size: 0.9em;
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        .player-item.available {
            background: #e8f5e9;
            border: 1px solid #4caf50;
        }

        .player-item.playing {
            background: #fff3e0;
            border: 1px solid #ff9800;
        }

        .player-item.absent {
            background: #ffebee;
            border: 1px solid #f44336;
            opacity: 0.6;
            text-decoration: line-through;
        }

        .player-controls {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .level-toggle {
            padding: 2px 6px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 0.7em;
            cursor: pointer;
            transition: background 0.3s;
        }

        .level-toggle:hover {
            background: #1976D2;
        }

        .level-toggle:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .player-status {
            font-size: 0.75em;
            padding: 2px 6px;
            border-radius: 12px;
            background: white;
            text-transform: capitalize;
        }

        .attendance-toggle {
            margin-bottom: 15px;
            padding: 12px;
            background: #f0f0f0;
            border-radius: 10px;
        }

        .attendance-toggle h4 {
            margin-bottom: 8px;
            color: #666;
            font-size: 0.9em;
        }

        .toggle-buttons {
            display: flex;
            gap: 8px;
        }

        .toggle-btn {
            padding: 6px 12px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 5px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.3s;
        }

        .toggle-btn:hover {
            background: #f5f5f5;
        }

        .toggle-btn.mark-all {
            background: #4caf50;
            color: white;
            border-color: #4caf50;
        }

        .toggle-btn.mark-absent {
            background: #f44336;
            color: white;
            border-color: #f44336;
        }

        .courts-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        @media (max-width: 768px) {
            .courts-section {
                grid-template-columns: 1fr;
                gap: 10px;
            }
        }

        .court-card {
            background: white;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            transition: transform 0.3s ease;
        }

        @media (min-width: 769px) {
            .court-card:hover {
                transform: translateY(-5px);
            }
        }

        @media (max-width: 768px) {
            .court-card {
                padding: 12px;
            }
        }

        .court-header {
            text-align: center;
            margin-bottom: 12px;
        }

        .court-number {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.95em;
        }

        .court-status {
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 8px;
            font-weight: bold;
        }

        .court-status.empty {
            background: #f5f5f5;
            color: #999;
        }

        .court-status.occupied {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .players-on-court {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }

        .player-on-court {
            padding: 8px;
            background: #f0f4ff;
            border-radius: 8px;
            text-align: center;
            font-size: 0.9em;
        }

        .player-on-court.intermediate {
            background: #fff3e0;
        }

        .btn {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-end {
            background: #f44336;
            color: white;
        }

        .btn-end:hover {
            background: #d32f2f;
        }

        .btn-assign {
            background: #4caf50;
            color: white;
        }

        .btn-assign:hover {
            background: #45a049;
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .queue-info {
            text-align: center;
            margin-top: 10px;
            font-size: 0.9em;
            color: #666;
        }

        /* Timer Styles */
        .timer-display {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 8px 12px;
            margin: 10px 0;
            text-align: center;
            font-family: 'Courier New', monospace;
            transition: all 0.3s ease;
        }

        .timer-display.active {
            background: #e8f5e9;
            border-color: #4caf50;
            animation: pulse 2s infinite;
        }

        .timer-display.stopped {
            background: #ffebee;
            border-color: #f44336;
        }

        .timer-display.paused {
            background: #fff8e1;
            border-color: #ff9800;
        }

        .timer-icon {
            font-size: 1.1em;
            margin-right: 5px;
        }

        .timer-time {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            margin: 0 8px;
        }

        .timer-display.active .timer-time {
            color: #2e7d32;
        }

        .timer-display.stopped .timer-time {
            color: #c62828;
        }

        .timer-label {
            font-size: 0.8em;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-left: 5px;
        }

        .timer-display.active .timer-label {
            color: #2e7d32;
        }

        .timer-display.stopped .timer-label {
            color: #c62828;
        }

        .timer-display.paused .timer-time {
            color: #f57c00;
        }

        .timer-display.paused .timer-label {
            color: #f57c00;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        /* Timer controls */
        .timer-controls {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }

        .timer-btn {
            flex: 1;
            padding: 4px 8px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .timer-btn:hover {
            background: #f5f5f5;
        }

        .timer-btn.start {
            background: #4caf50;
            color: white;
            border-color: #4caf50;
        }

        .timer-btn.start:hover {
            background: #45a049;
        }

        .timer-btn.stop {
            background: #f44336;
            color: white;
            border-color: #f44336;
        }

        .timer-btn.stop:hover {
            background: #d32f2f;
        }

        .timer-btn:disabled {
            background: #e9ecef;
            color: #6c757d;
            cursor: not-allowed;
        }

        /* Manual Assignment Styles */
        .btn-manual {
            background: #2196F3;
            color: white;
            margin-top: 5px;
        }

        .btn-manual:hover {
            background: #1976D2;
        }

        .assignment-buttons {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .assignment-buttons .btn {
            margin: 0;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 20px;
            border-radius: 10px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eee;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: #000;
        }

        .player-selection {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .player-option {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
        }

        .player-option:hover {
            border-color: #2196F3;
            background-color: #f0f8ff;
        }

        .player-option.selected {
            border-color: #4caf50;
            background-color: #e8f5e9;
            color: #2e7d32;
        }

        .player-option.intermediate {
            background-color: #fff3e0;
        }

        .player-option.beginner {
            background-color: #f0f4ff;
        }

        .selected-count {
            text-align: center;
            margin: 15px 0;
            font-weight: bold;
            font-size: 1.1em;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-btn-primary {
            background: #4caf50;
            color: white;
        }

        .modal-btn-primary:hover {
            background: #45a049;
        }

        .modal-btn-secondary {
            background: #f44336;
            color: white;
        }

        .modal-btn-secondary:hover {
            background: #d32f2f;
        }

        .add-player-form {
            margin-bottom: 15px;
            padding: 12px;
            background: #f9f9f9;
            border-radius: 10px;
        }

        .form-group {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .form-group input {
            flex: 1;
            min-width: 150px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .form-group select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .add-player-form {
                padding: 10px;
            }

            .form-group {
                flex-direction: column;
            }

            .form-group input,
            .form-group select {
                width: 100%;
            }
        }

        /* Touch-friendly buttons for mobile */
        @media (max-width: 768px) {
            .btn {
                padding: 12px;
                font-size: 0.95em;
                -webkit-tap-highlight-color: transparent;
            }
        }

        /* Improve scrolling on mobile */
        @media (max-width: 768px) {
            .players-section,
            .courts-section {
                -webkit-overflow-scrolling: touch;
            }
        }

        /* Loading indicator for better UX */
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè∏ Shingw√†kons PS Badminton Club</h1>
            <div class="stats">
                <div class="stat-card">
                    <strong>Total Players:</strong> <span id="totalPlayers">34</span>
                </div>
                <div class="stat-card">
                    <strong>Available Courts:</strong> <span id="availableCourts">4</span>
                </div>
                <div class="stat-card">
                    <strong>Active Games:</strong> <span id="activeGames">0</span>
                </div>
            </div>
        </div>

        <div class="mobile-tabs">
            <div class="tab-buttons">
                <button class="tab-btn active" onclick="switchTab('players')">Players</button>
                <button class="tab-btn" onclick="switchTab('courts')">Courts</button>
            </div>
        </div>

        <div class="main-content">
            <div class="players-section active" id="playersSection">
                <h2>Players Management</h2>
                
                <div class="add-player-form">
                    <div class="form-group">
                        <input type="text" id="newPlayerName" placeholder="Player name (or Guest 1, Guest 2, etc.)">
                        <select id="newPlayerLevel">
                            <option value="beginner">Beginner</option>
                            <option value="intermediate">Intermediate</option>
                            <option value="guest-beginner">Guest (Beginner)</option>
                            <option value="guest-intermediate">Guest (Intermediate)</option>
                        </select>
                    </div>
                    <button class="btn btn-assign" onclick="addPlayer()">Add Player</button>
                </div>

                <div class="attendance-toggle">
                    <h4>Quick Attendance Actions</h4>
                    <div class="toggle-buttons">
                        <button class="toggle-btn mark-all" onclick="markAllPresent()">Mark All Present</button>
                        <button class="toggle-btn mark-absent" onclick="markAllAbsent()">Mark All Absent</button>
                    </div>
                </div>

                <div class="attendance-toggle">
                    <h4>Data Management</h4>
                    <div class="toggle-buttons">
                        <button class="toggle-btn" onclick="clearAllData()" style="background: #ff5722; border-color: #ff5722;">Reset All Data</button>
                        <button class="toggle-btn" onclick="clearCache()" style="background: #9c27b0; border-color: #9c27b0;">Clear Cache</button>
                        <button class="toggle-btn" onclick="fixFirebaseData()" style="background: #ff9800; border-color: #ff9800;">Fix Firebase</button>
                    </div>
                </div>

                <div class="player-group">
                    <h3>Intermediate Players (<span id="intermediateCount">10</span>)</h3>
                    <p style="font-size: 0.8em; color: #666; margin-bottom: 8px;">Click on a player to toggle attendance</p>
                    <div class="player-list" id="intermediatePlayers"></div>
                </div>

                <div class="player-group">
                    <h3>Beginner Players (<span id="beginnerCount">24</span>)</h3>
                    <p style="font-size: 0.8em; color: #666; margin-bottom: 8px;">Click on a player to toggle attendance</p>
                    <div class="player-list" id="beginnerPlayers"></div>
                </div>
            </div>

            <div class="courts-section" id="courtsSection">
                <!-- Courts will be dynamically generated -->
            </div>
        </div>
    </div>

    <script>
        // Tab switching for mobile
        function switchTab(tab) {
            const playersSection = document.getElementById('playersSection');
            const courtsSection = document.getElementById('courtsSection');
            const tabButtons = document.querySelectorAll('.tab-btn');

            if (tab === 'players') {
                playersSection.classList.add('active');
                courtsSection.classList.remove('active');
                tabButtons[0].classList.add('active');
                tabButtons[1].classList.remove('active');
            } else {
                playersSection.classList.remove('active');
                courtsSection.classList.add('active');
                tabButtons[0].classList.remove('active');
                tabButtons[1].classList.add('active');
            }
        }

        // Check if mobile
        function isMobile() {
            return window.innerWidth <= 768;
        }

        // Auto switch to courts tab on mobile when assigning
        function assignPlayers(courtId) {
            const court = courts.find(c => c.id === courtId);
            if (court.occupied) return;

            const availableIntermediate = players.intermediate.filter(p => p.status === 'available');
            const availableBeginner = players.beginner.filter(p => p.status === 'available');

            let selectedPlayers = [];

            // All courts are assigned based on availability
                // Prioritize intermediate players if we have 4 or more
                if (availableIntermediate.length >= 4) {
                    selectedPlayers = getRandomPlayers(availableIntermediate, 4);
                    console.log(`Court ${courtId} (Mixed): Selected intermediate players - ${selectedPlayers.map(p => p.name).join(', ')}`);
                } else if (availableBeginner.length >= 4) {
                    selectedPlayers = getRandomPlayers(availableBeginner, 4);
                    console.log(`Court ${courtId} (Mixed): Selected beginner players - ${selectedPlayers.map(p => p.name).join(', ')}`);
                } else if (availableIntermediate.length + availableBeginner.length >= 4) {
                    // Mixed level game when not enough of single level but combined >= 4
                    const mixedPlayers = [...availableIntermediate, ...availableBeginner];
                    selectedPlayers = getRandomPlayers(mixedPlayers, 4);
                    console.log(`Court ${courtId} (Mixed Levels): Selected mixed players - ${selectedPlayers.map(p => `${p.name}(${p.level})`).join(', ')}`);
                } else {
                    alert(`Not enough players available for Court ${courtId}. Need 4 players but only ${availableIntermediate.length} intermediate and ${availableBeginner.length} beginner players available.`);
                    return;
                }

            // Update player status
            selectedPlayers.forEach(player => {
                player.status = 'playing';
            });

            // Update court
            court.occupied = true;
            court.players = selectedPlayers;

            // Start the timer for this court
            startCourtTimer(courtId);

            renderPlayers();
            renderCourts();
            updateStats();
            
            // Send push notifications
            checkForPlayerTurn(selectedPlayers);
            
            // Sync court assignment to Firebase
            console.log('üè∏ Syncing court assignment to Firebase');
            savePlayersDataWithSync();

            // Switch to courts tab on mobile after assigning
            if (isMobile()) {
                setTimeout(() => switchTab('courts'), 100);
            }
        }

        // Game state
        let players = {
            intermediate: [],
            beginner: []
        };

        let courts = [
            { id: 1, occupied: false, players: [], startTime: null, elapsedTime: 0 },
            { id: 2, occupied: false, players: [], startTime: null, elapsedTime: 0 },
            { id: 3, occupied: false, players: [], startTime: null, elapsedTime: 0 },
            { id: 4, occupied: false, players: [], startTime: null, elapsedTime: 0 }
        ];

        // Timer management
        let timerInterval = null;

        // Start timer for a court
        function startCourtTimer(courtId) {
            const court = courts.find(c => c.id === courtId);
            if (court && court.occupied) {
                if (!court.startTime) {
                    // Starting fresh or resuming - adjust start time based on elapsed time
                    court.startTime = Date.now() - (court.elapsedTime || 0);
                    console.log(`‚è±Ô∏è Timer started for Court ${courtId} (resuming from ${formatTime(court.elapsedTime || 0)})`);
                } else {
                    console.log(`‚è±Ô∏è Timer already running for Court ${courtId}`);
                    return;
                }
                
                // Start the global timer update if not already running
                if (!timerInterval) {
                    timerInterval = setInterval(updateAllTimers, 1000);
                }
                
                // Update display immediately
                renderCourts();
            }
        }

        // Pause timer for a court (stops timer but keeps elapsed time)
        function pauseCourtTimer(courtId) {
            const court = courts.find(c => c.id === courtId);
            if (court && court.startTime) {
                // Calculate total elapsed time including current session
                court.elapsedTime = Date.now() - court.startTime;
                court.startTime = null; // Mark as paused
                console.log(`‚è∏Ô∏è Timer paused for Court ${courtId}. Duration: ${formatTime(court.elapsedTime)}`);
                
                // Stop global timer if no courts are active
                const anyActiveTimer = courts.some(c => c.startTime !== null);
                if (!anyActiveTimer && timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
                
                // Update display immediately
                renderCourts();
            }
        }

        // Stop timer for a court (used when ending game)
        function stopCourtTimer(courtId) {
            const court = courts.find(c => c.id === courtId);
            if (court) {
                if (court.startTime) {
                    // Calculate final elapsed time
                    court.elapsedTime = Date.now() - court.startTime;
                }
                const finalTime = court.elapsedTime || 0;
                console.log(`üèÅ Timer stopped for Court ${courtId}. Final Duration: ${formatTime(finalTime)}`);
                
                // Reset timer data
                court.startTime = null;
                court.elapsedTime = 0;
                
                // Stop global timer if no courts are active
                const anyActiveTimer = courts.some(c => c.startTime !== null);
                if (!anyActiveTimer && timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
                
                return finalTime; // Return final time for game end summary
            }
            return 0;
        }

        // Update all active timers
        function updateAllTimers() {
            let hasActiveTimer = false;
            courts.forEach(court => {
                if (court.startTime && court.occupied) {
                    hasActiveTimer = true;
                    court.elapsedTime = Date.now() - court.startTime;
                }
            });
            
            // Update the display
            renderCourts();
            
            // Stop interval if no active timers
            if (!hasActiveTimer) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        // Format time in MM:SS format
        function formatTime(milliseconds) {
            const totalSeconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Get timer display for a court
        function getTimerDisplay(court) {
            if (!court.occupied) {
                return '';
            }
            
            let timeToShow = 0;
            if (court.startTime) {
                timeToShow = Date.now() - court.startTime;
            } else if (court.elapsedTime > 0) {
                timeToShow = court.elapsedTime;
            }
            
            const formattedTime = formatTime(timeToShow);
            const isActive = court.startTime !== null;
            const isPaused = !isActive && court.elapsedTime > 0;
            
            let statusIcon, statusLabel, statusClass;
            if (isActive) {
                statusIcon = 'üü¢';
                statusLabel = 'Playing';
                statusClass = 'active';
            } else if (isPaused) {
                statusIcon = 'üü°';
                statusLabel = 'Paused';
                statusClass = 'paused';
            } else {
                statusIcon = 'üî¥';
                statusLabel = 'Stopped';
                statusClass = 'stopped';
            }
            
            return `
                <div class="timer-display ${statusClass}">
                    <span class="timer-icon">${statusIcon}</span>
                    <span class="timer-time">${formattedTime}</span>
                    <span class="timer-label">${statusLabel}</span>
                </div>
            `;
        }

        // Save players data to localStorage
        function savePlayersData() {
            try {
                const dataToSave = {
                    players: players,
                    courts: courts,
                    timestamp: Date.now()
                };
                localStorage.setItem('badmintonClubData', JSON.stringify(dataToSave));
                console.log('‚úÖ Data saved to localStorage');
            } catch (error) {
                console.error('‚ùå Error saving data:', error);
            }
        }

        // Load players data from localStorage
        function loadPlayersData() {
            try {
                const savedData = localStorage.getItem('badmintonClubData');
                if (savedData) {
                    const parsedData = JSON.parse(savedData);
                    
                    // Load saved players data
                    if (parsedData.players) {
                        players = parsedData.players;
                        console.log('‚úÖ Loaded saved player data');
                    }
                    
                    // Reset courts (don't persist games across sessions)
                    courts.forEach(court => {
                        court.occupied = false;
                        court.players = [];
                    });
                    
                    // Ensure all players are available (reset playing status)
                    players.intermediate.forEach(player => {
                        if (player.status === 'playing') {
                            player.status = 'available';
                        }
                    });
                    players.beginner.forEach(player => {
                        if (player.status === 'playing') {
                            player.status = 'available';
                        }
                    });
                    
                    return true; // Data was loaded
                }
            } catch (error) {
                console.error('‚ùå Error loading data:', error);
            }
            return false; // No data was loaded
        }

        // Initialize players with default data or load from storage
        function initializePlayers() {
            // Try to load saved data first
            if (loadPlayersData()) {
                console.log('üìÇ Loaded existing player data from storage');
                renderPlayers();
                renderCourts();
                updateStats();
                return;
            }

            // If no saved data, create default players
            console.log('üÜï Creating default player data');
            
            // Add intermediate players (11 players - updated)
            const intermediatePlayerNames = [
                'Mohsin Yasin',
                'Awais',
                'Shaheryar Afroze',
                'Ali BIN ARSHAD',
                'Arslan Rafiq',
                'Asad',
                'Ghazanfar',
                'Hamid Jan',
                'Mavia',
                'Usman',
                'Waqas'
            ];

            intermediatePlayerNames.forEach((name, index) => {
                players.intermediate.push({
                    id: `int${index + 1}`,
                    name: name,
                    status: 'available',
                    level: 'intermediate',
                    queueTimestamp: Date.now() // Track when they became available
                });
            });

            // Add beginner players (23 players - updated with full phone numbers)
            const beginnerPlayerNames = [
                'Moid',
                'Muhammad Khizar',
                'HM',
                '+1 (343) 988-0245',
                '+1 (343) 999-2247',
                '+1 (416) 319-3817',
                '+1 (514) 995-8939',
                '+1 (613) 298-5451',
                '+1 (613) 299-3159',
                '+1 (613) 413-4170',
                '+1 (613) 413-5563',
                '+1 (613) 513-4953',
                '+1 (613) 761-0152',
                '+1 (613) 864-1844',
                '+1 (613) 890-4942',
                '+1 (613) 890-9456',
                '+1 (613) 914-8481',
                '+1 (613) 986-5423',
                '+1 (647) 760-1986',
                '+1 (873) 288-4800',
                '+1 (902) 989-4918',
                '+1 (905) 462-7420',
                'Guest Player'
            ];

            beginnerPlayerNames.forEach((name, index) => {
                players.beginner.push({
                    id: `beg${index + 1}`,
                    name: name,
                    status: 'available',
                    level: 'beginner',
                    queueTimestamp: Date.now() // Track when they became available
                });
            });

            // Save the initial data
            savePlayersData();

            renderPlayers();
            renderCourts();
            updateStats();
            
        }


        // Add new player
        function addPlayer() {
            const name = document.getElementById('newPlayerName').value.trim();
            const levelSelect = document.getElementById('newPlayerLevel').value;

            if (!name) {
                alert('Please enter a player name');
                return;
            }

            // Determine the actual level and if it's a guest
            let level = levelSelect.includes('guest-') ? levelSelect.replace('guest-', '') : levelSelect;
            let displayName = levelSelect.includes('guest-') ? `${name} (Guest)` : name;

            // Check for duplicate names across all players
            const allPlayers = [...players.intermediate, ...players.beginner];
            const duplicateName = allPlayers.find(p => p.name.toLowerCase() === displayName.toLowerCase());
            if (duplicateName) {
                alert(`A player named "${duplicateName.name}" already exists! Please choose a different name.`);
                return;
            }

            const player = {
                id: `${level}_${Date.now()}`,
                name: displayName,
                status: 'available',
                level: level,
                isGuest: levelSelect.includes('guest-'),
                queueTimestamp: Date.now() // New players go to end of queue
            };

            players[level].push(player);
            
            document.getElementById('newPlayerName').value = '';
            
            renderPlayers();
            updateStats();
            savePlayersDataWithSync(); // Save after adding new player
        }

        // Render players list
        function renderPlayers() {
            const intermediateContainer = document.getElementById('intermediatePlayers');
            const beginnerContainer = document.getElementById('beginnerPlayers');

            intermediateContainer.innerHTML = '';
            beginnerContainer.innerHTML = '';

            players.intermediate.forEach(player => {
                intermediateContainer.appendChild(createPlayerElement(player));
            });

            players.beginner.forEach(player => {
                beginnerContainer.appendChild(createPlayerElement(player));
            });

            document.getElementById('intermediateCount').textContent = players.intermediate.length;
            document.getElementById('beginnerCount').textContent = players.beginner.length;
        }

        // Create player element
        function createPlayerElement(player) {
            const div = document.createElement('div');
            div.className = `player-item ${player.status}`;
            
            let statusText = player.status;
            if (player.status === 'absent') {
                statusText = 'absent';
            } else if (player.status === 'playing') {
                statusText = 'playing';
            } else {
                statusText = 'present';
            }
            
            const targetLevel = player.level === 'intermediate' ? 'beginner' : 'intermediate';
            const buttonText = player.level === 'intermediate' ? '‚Üí Beg' : '‚Üí Int';
            const isPlaying = player.status === 'playing';
            
            // Add click handler to the entire div
            div.onclick = function(event) {
                // Don't trigger if clicking on control buttons
                if (event.target.classList.contains('level-toggle') || 
                    event.target.classList.contains('delete-btn') || 
                    event.target.classList.contains('rename-btn')) {
                    return;
                }
                console.log('Click detected on', player.name);
                togglePlayerAttendanceById(player.id, player.level);
            };
            
            div.innerHTML = `
                <span style="flex: 1;">${player.name}</span>
                <div class="player-controls">
                    <button class="level-toggle" onclick="event.stopPropagation(); changePlayerLevel('${player.id}', '${player.level}', '${targetLevel}')" ${isPlaying ? 'disabled' : ''} title="Move to ${targetLevel}">
                        ${buttonText}
                    </button>
                    <button class="rename-btn" onclick="event.stopPropagation(); renamePlayer('${player.id}', '${player.level}')" ${isPlaying ? 'disabled' : ''} title="Rename player" style="padding: 2px 6px; background: #2196F3; color: white; border: none; border-radius: 4px; font-size: 0.7em; cursor: pointer; margin-left: 3px;">
                        ‚úèÔ∏è
                    </button>
                    <button class="delete-btn" onclick="event.stopPropagation(); deletePlayer('${player.id}', '${player.level}')" ${isPlaying ? 'disabled' : ''} title="Delete player" style="padding: 2px 6px; background: #f44336; color: white; border: none; border-radius: 4px; font-size: 0.7em; cursor: pointer; margin-left: 3px;">
                        üóëÔ∏è
                    </button>
                    <span class="player-status">${statusText}</span>
                </div>
            `;
            return div;
        }

        // Change player level
        function changePlayerLevel(playerId, currentLevel, targetLevel) {
            // Find the player in current level
            const playerIndex = players[currentLevel].findIndex(p => p.id === playerId);
            if (playerIndex === -1) return;
            
            const player = players[currentLevel][playerIndex];
            
            // Can't move if playing
            if (player.status === 'playing') {
                alert('Cannot change level while player is in a game!');
                return;
            }
            
            // Remove from current level
            players[currentLevel].splice(playerIndex, 1);
            
            // Change level and add to target level
            player.level = targetLevel;
            players[targetLevel].push(player);
            
            // Sort players by name for better organization
            players[targetLevel].sort((a, b) => a.name.localeCompare(b.name));
            
            renderPlayers();
            updateStats();
            savePlayersDataWithSync(); // Save after level change
            
            console.log(`Moved ${player.name} from ${currentLevel} to ${targetLevel}`);
        }

        // Delete player function
        function deletePlayer(playerId, level) {
            const player = players[level].find(p => p.id === playerId);
            if (!player) {
                console.error(`Player not found: ${playerId} in ${level}`);
                return;
            }

            if (player.status === 'playing') {
                alert('Cannot delete a player who is currently playing. End their game first.');
                return;
            }

            const confirmDelete = confirm(`Are you sure you want to delete "${player.name}"? This action cannot be undone.`);
            if (confirmDelete) {
                const playerIndex = players[level].findIndex(p => p.id === playerId);
                players[level].splice(playerIndex, 1);
                
                console.log(`Deleted player: ${player.name}`);
                renderPlayers();
                updateStats();
                savePlayersDataWithSync(); // Save after deletion
            }
        }

        // Rename player function
        function renamePlayer(playerId, level) {
            const player = players[level].find(p => p.id === playerId);
            if (!player) {
                console.error(`Player not found: ${playerId} in ${level}`);
                return;
            }

            if (player.status === 'playing') {
                alert('Cannot rename a player who is currently playing. End their game first.');
                return;
            }

            const newName = prompt(`Enter new name for "${player.name}":`, player.name);
            if (newName && newName.trim() && newName.trim() !== player.name) {
                const trimmedName = newName.trim();
                
                // Check for duplicate names across all players (excluding current player)
                const allPlayers = [...players.intermediate, ...players.beginner];
                const duplicateName = allPlayers.find(p => p.id !== playerId && p.name.toLowerCase() === trimmedName.toLowerCase());
                if (duplicateName) {
                    alert(`A player named "${duplicateName.name}" already exists! Please choose a different name.`);
                    return;
                }
                
                const oldName = player.name;
                player.name = trimmedName;
                
                console.log(`Renamed player: "${oldName}" ‚Üí "${player.name}"`);
                renderPlayers();
                savePlayersDataWithSync(); // Save after rename
            }
        }

        // Toggle player attendance by ID and level
        function togglePlayerAttendanceById(playerId, level) {
            
            const player = players[level].find(p => p.id === playerId);
            if (!player) {
                console.error(`Player not found: ${playerId} in ${level}`);
                alert(`Player not found: ${playerId}`);
                return;
            }
            
            togglePlayerAttendance(player);
        }

        // Toggle player attendance
        function togglePlayerAttendance(player) {
            if (!player) return;
            
            if (player.status === 'playing') {
                alert('Cannot mark a playing player as absent. End their game first.');
                return;
            }
            
            if (player.status === 'absent') {
                player.status = 'available';
                // When player returns from absent, they get a new queue timestamp (go to end of queue)
                player.queueTimestamp = Date.now();
            } else {
                player.status = 'absent';
            }
            
            renderPlayers();
            updateStats();
            savePlayersDataWithSync(); // Save after attendance change
        }

        // Mark all players as present
        function markAllPresent() {
            players.intermediate.forEach(player => {
                if (player.status === 'absent') {
                    player.status = 'available';
                }
            });
            players.beginner.forEach(player => {
                if (player.status === 'absent') {
                    player.status = 'available';
                }
            });
            renderPlayers();
            updateStats();
            savePlayersDataWithSync(); // Save after bulk attendance change
        }

        // Mark all players as absent
        function markAllAbsent() {
            if (confirm('This will mark all non-playing players as absent. Continue?')) {
                players.intermediate.forEach(player => {
                    if (player.status !== 'playing') {
                        player.status = 'absent';
                    }
                });
                players.beginner.forEach(player => {
                    if (player.status !== 'playing') {
                        player.status = 'absent';
                    }
                });
                renderPlayers();
                updateStats();
                savePlayersDataWithSync(); // Save after bulk attendance change
            }
        }

        // Render courts
        function renderCourts() {
            const container = document.getElementById('courtsSection');
            container.innerHTML = '';

            courts.forEach(court => {
                const courtCard = createCourtCard(court);
                container.appendChild(courtCard);
            });
        }

        // Create court card
        function createCourtCard(court) {
            const div = document.createElement('div');
            div.className = 'court-card';

            const statusClass = court.occupied ? 'occupied' : 'empty';
            const statusText = court.occupied ? 'Game in Progress' : 'Court Available';

            let playersHTML = '';
            if (court.occupied && court.players.length === 4) {
                playersHTML = `
                    <div class="players-on-court">
                        ${court.players.map(p => `
                            <div class="player-on-court ${p.level}">${p.name}</div>
                        `).join('')}
                    </div>
                `;
            }

            const queueInfo = getQueueInfo(court);

            // No special indicators for any courts
            const courtSpecialInfo = '';

            div.innerHTML = `
                <div class="court-header">
                    <span class="court-number">Court ${court.id}</span>
                </div>
                ${courtSpecialInfo}
                <div class="court-status ${statusClass}">${statusText}</div>
                ${getTimerDisplay(court)}
                ${playersHTML}
                ${court.occupied ? 
                    `<div class="timer-controls">
                        <button class="timer-btn ${court.startTime ? 'stop' : 'start'}" onclick="${court.startTime ? `pauseCourtTimer(${court.id})` : `startCourtTimer(${court.id})`}" ${!court.occupied ? 'disabled' : ''}>
                            ${court.startTime ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Resume'}
                        </button>
                        <button class="btn btn-end" onclick="endGame(${court.id})" style="margin-top: 5px;">End Game</button>
                    </div>` :
                    `<div class="assignment-buttons">
                        <button class="btn btn-assign" onclick="assignPlayers(${court.id})" ${!canAssignPlayers(court.id) ? 'disabled' : ''}>
                            üé≤ Auto Assign
                        </button>
                        <button class="btn btn-manual" onclick="openManualAssignment(${court.id})" ${!canAssignPlayers(court.id) ? 'disabled' : ''}>
                            üë• Manual Select
                        </button>
                    </div>`
                }
                <div class="queue-info">${queueInfo}</div>
            `;

            return div;
        }

        // Get queue info for a court
        function getQueueInfo(court) {
            return ''; // Queue info removed per user request
        }

        // Check if we can assign players (court-specific logic)
        function canAssignPlayers(courtId = null) {
            const availableIntermediate = players.intermediate.filter(p => p.status === 'available').length;
            const availableBeginner = players.beginner.filter(p => p.status === 'available').length;
            
            // All courts can use either level
            // Also allow mixed games when individual levels don't have 4 players
            return availableIntermediate >= 4 || availableBeginner >= 4 || 
                   (availableIntermediate + availableBeginner >= 4);
        }

        // Get players with queue priority
        function getRandomPlayers(playersList, count) {
            const preferredNames = ['Mohsin Yasin', 'Mavia', 'Ali BIN ARSHAD', 'Asad'];
            const biasChance = 0.75; // 75% chance to select preferred players
            
            // Sort players by queue time (oldest first) - this is the queue system
            const sortedByQueue = [...playersList].sort((a, b) => a.queueTimestamp - b.queueTimestamp);
            
            // Separate preferred and other players (maintaining queue order)
            const preferredPlayers = sortedByQueue.filter(p => preferredNames.includes(p.name));
            const otherPlayers = sortedByQueue.filter(p => !preferredNames.includes(p.name));
            
            
            // If we don't have enough preferred players, or random chance says no bias
            if (preferredPlayers.length < count || Math.random() > biasChance) {
                return sortedByQueue.slice(0, count);
            }
            
            // Use biased selection but still respect queue order within groups
            let selectedPlayers = [];
            
            // First, select preferred players (in queue order)
            const maxPreferredToSelect = Math.min(count, preferredPlayers.length);
            selectedPlayers.push(...preferredPlayers.slice(0, maxPreferredToSelect));
            
            // Fill remaining slots with other players (in queue order)
            const remainingSlots = count - selectedPlayers.length;
            if (remainingSlots > 0) {
                selectedPlayers.push(...otherPlayers.slice(0, remainingSlots));
            }
            
            console.log(`Selected players: ${selectedPlayers.map(p => p.name).join(', ')}`);
            console.log(`Preferred players selected: ${selectedPlayers.filter(p => preferredNames.includes(p.name)).length}/${count}`);
            
            return selectedPlayers;
        }

        // End game on a court
        function endGame(courtId) {
            const court = courts.find(c => c.id === courtId);
            if (!court.occupied) return;

            // Get final time and stop the timer
            const finalTime = stopCourtTimer(courtId);
            const gameTimeFormatted = formatTime(finalTime);

            console.log(`=== GAME ENDING ON COURT ${courtId} ===`);
            console.log(`Players finishing: ${court.players.map(p => p.name).join(', ')}`);

            // Show game summary
            const playerNames = court.players.map(p => p.name).join(', ');
            const summaryMessage = `üè∏ Game Complete!\n\nCourt ${courtId}\nPlayers: ${playerNames}\nGame Duration: ${gameTimeFormatted}\n\nGreat game everyone! üéâ`;
            
            alert(summaryMessage);

            // Update player status back to available and put them at END of queue
            court.players.forEach(player => {
                player.status = 'available';
                player.queueTimestamp = Date.now(); // New timestamp puts them at end of queue
                console.log(`${player.name} moved to end of queue with timestamp: ${player.queueTimestamp}`);
            });

            // Clear court
            court.occupied = false;
            court.players = [];

            renderPlayers();
            renderCourts();
            updateStats();
            
            // Sync court end game to Firebase
            console.log('üè∏ Syncing court end game to Firebase');
            savePlayersDataWithSync();

            // Auto-assign next match if players are waiting
            setTimeout(() => {
                if (canAssignPlayers()) {
                    // You can uncomment this to auto-assign
                    // assignPlayers(courtId);
                }
            }, 500);
        }

        // Clear all data and reset to defaults
        function clearAllData() {
            const confirmClear = confirm('‚ö†Ô∏è This will reset ALL player data (names, attendance, etc.) back to defaults. This cannot be undone. Are you sure?');
            if (confirmClear) {
                // Clear localStorage
                localStorage.removeItem('badmintonClubData');
                console.log('üóëÔ∏è Cleared all saved data');
                
                // Reset players arrays
                players.intermediate = [];
                players.beginner = [];
                
                // Reset courts
                courts.forEach(court => {
                    court.occupied = false;
                    court.players = [];
                });
                
                // Reinitialize with default data
                initializePlayers();
                
                alert('‚úÖ All data has been reset to defaults!');
            }
        }

        // Clear browser cache and localStorage
        function clearCache() {
            if (confirm('‚ö†Ô∏è This will clear all cached data and refresh the page. Continue?')) {
                try {
                    // Clear localStorage
                    localStorage.clear();
                    
                    // Clear sessionStorage
                    sessionStorage.clear();
                    
                    // Clear service worker cache if available
                    if ('serviceWorker' in navigator && 'caches' in window) {
                        caches.keys().then(function(cacheNames) {
                            return Promise.all(
                                cacheNames.map(function(cacheName) {
                                    return caches.delete(cacheName);
                                })
                            );
                        });
                    }
                    
                    console.log('üßπ Cache cleared successfully');
                    alert('‚úÖ Cache cleared! Page will refresh.');
                    
                    // Force refresh without cache
                    window.location.reload(true);
                    
                } catch (error) {
                    console.error('‚ùå Error clearing cache:', error);
                    alert('‚ùå Error clearing cache. Try manually clearing browser data.');
                }
            }
        }

        // Fix Firebase data structure
        function fixFirebaseData() {
            if (!isFirebaseConnected) {
                alert('‚ùå Firebase not connected. Cannot fix data.');
                return;
            }

            const confirmFix = confirm('üîß This will clear corrupted Firebase data and upload fresh player data. Continue?');
            if (confirmFix) {
                console.log('üîß Fixing Firebase data structure...');
                
                // Clear corrupted Firebase data first
                database.ref('badmintonClub').remove()
                    .then(() => {
                        console.log('üóëÔ∏è Cleared corrupted Firebase data');
                        
                        // Reset local data to defaults
                        players.intermediate = [];
                        players.beginner = [];
                        
                        // Initialize with fresh default data
                        initializePlayers();
                        
                        alert('‚úÖ Firebase data fixed! Try renaming a player now.');
                    })
                    .catch((error) => {
                        console.error('‚ùå Failed to clear Firebase data:', error);
                        alert('‚ùå Failed to fix Firebase data: ' + error.message);
                    });
            }
        }

        // Update statistics
        function updateStats() {
            const totalPresent = players.intermediate.filter(p => p.status !== 'absent').length + 
                               players.beginner.filter(p => p.status !== 'absent').length;
            const activeGames = courts.filter(c => c.occupied).length;
            const availableCourts = courts.filter(c => !c.occupied).length;

            document.getElementById('totalPlayers').textContent = totalPresent + ' present';
            document.getElementById('activeGames').textContent = activeGames;
            document.getElementById('availableCourts').textContent = availableCourts;
        }

        // Firebase Configuration and Real-time Database Integration
        let firebaseApp = null;
        let database = null;
        let isFirebaseConnected = false;
        let isInitializing = true;
        let currentUserId = 'user-' + Math.random().toString(36).substr(2, 9); // Unique user ID for this session

        // Firebase configuration - Shingw√†kons PS Badminton Club
        const firebaseConfig = {
            apiKey: "AIzaSyCcW9gyRlIDGxLdqNIt5hZN5pQOzsjWSsU",
            authDomain: "shingwakons-badminton-club.firebaseapp.com",
            databaseURL: "https://shingwakons-badminton-club-default-rtdb.firebaseio.com/",
            projectId: "shingwakons-badminton-club",
            storageBucket: "shingwakons-badminton-club.firebasestorage.app",
            messagingSenderId: "37974035469",
            appId: "1:37974035469:web:f8809c731372c5da005944"
        };

        // Initialize Firebase
        function initializeFirebase() {
            try {
                // Check if config has been updated from placeholder
                if (firebaseConfig.apiKey === "YOUR_API_KEY_HERE") {
                    console.log('üîß Firebase not configured yet - using localStorage only');
                    console.log('üìã See FIREBASE-SETUP-GUIDE.md for setup instructions');
                    isFirebaseConnected = false;
                    return false;
                }

                firebaseApp = firebase.initializeApp(firebaseConfig);
                database = firebase.database();
                
                // Test connection
                database.ref('.info/connected').on('value', (snapshot) => {
                    if (snapshot.val() === true) {
                        isFirebaseConnected = true;
                        console.log('‚úÖ Firebase connected - real-time sync enabled');
                        showConnectionStatus('üåê Live sync enabled');
                        
                        // Load data from Firebase on first connection
                        if (isInitializing) {
                            loadDataFromFirebase();
                        }
                    } else {
                        isFirebaseConnected = false;
                        console.log('‚ùå Firebase disconnected - using localStorage backup');
                        showConnectionStatus('üì± Offline mode');
                    }
                });

                // Listen for real-time data changes
                database.ref('badmintonClub').on('value', (snapshot) => {
                    if (!isInitializing && snapshot.exists()) {
                        const firebaseData = snapshot.val();
                        if (firebaseData && firebaseData.players) {
                            // Only update if this change came from another user
                            if (firebaseData.updatedBy !== currentUserId) {
                                console.log('üîÑ Received real-time update from another user');
                                console.log('üìä Firebase data:', firebaseData);
                                
                                // Check if courts changed
                                const courtsChanged = firebaseData.courts && 
                                    JSON.stringify(firebaseData.courts) !== JSON.stringify(courts);
                                
                                updateLocalDataFromFirebase(firebaseData);
                                
                                if (courtsChanged) {
                                    showConnectionStatus('üè∏ Courts updated');
                                } else {
                                    showConnectionStatus('üîÑ Data updated');
                                }
                            } else {
                                console.log('üìù Ignoring own update');
                            }
                        }
                    }
                });

                return true;
            } catch (error) {
                console.error('‚ùå Firebase initialization failed:', error);
                isFirebaseConnected = false;
                return false;
            }
        }

        // Show connection status to users
        function showConnectionStatus(message) {
            // Remove existing status
            const existingStatus = document.getElementById('connection-status');
            if (existingStatus) existingStatus.remove();

            // Create status indicator
            const statusDiv = document.createElement('div');
            statusDiv.id = 'connection-status';
            statusDiv.style.cssText = `
                position: fixed;
                top: 60px;
                right: 20px;
                background: ${isFirebaseConnected ? '#4caf50' : '#ff9800'};
                color: white;
                padding: 8px 15px;
                border-radius: 20px;
                font-size: 12px;
                z-index: 999;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                transition: all 0.3s ease;
            `;
            statusDiv.textContent = message;
            document.body.appendChild(statusDiv);

            // Auto-hide after 3 seconds
            setTimeout(() => {
                if (statusDiv.parentNode) {
                    statusDiv.style.opacity = '0';
                    setTimeout(() => statusDiv.remove(), 300);
                }
            }, 3000);
        }

        // Save data to Firebase (with localStorage fallback)
        function saveDataToFirebase() {
            const dataToSave = {
                players: players,
                courts: courts, // Add courts to Firebase sync
                lastUpdated: Date.now(),
                updatedBy: currentUserId
            };

            console.log('üíæ Attempting to save data...');

            // Always save to localStorage as backup
            savePlayersData();

            // Try to save to Firebase if connected
            if (isFirebaseConnected && database) {
                try {
                    database.ref('badmintonClub').set(dataToSave)
                        .then(() => {
                            console.log('‚úÖ Data successfully synced to Firebase');
                            showConnectionStatus('‚úÖ Data synced');
                        })
                        .catch((error) => {
                            console.error('‚ùå Firebase save failed:', error);
                            console.error('Error details:', error.code, error.message);
                            showConnectionStatus('‚ùå Sync failed');
                            alert('Firebase save failed: ' + error.message);
                        });
                } catch (error) {
                    console.error('‚ùå Firebase save error:', error);
                    showConnectionStatus('‚ùå Sync error');
                }
            } else {
                showConnectionStatus('üì± Offline mode');
            }
        }

        // Load data from Firebase
        function loadDataFromFirebase() {
            if (!isFirebaseConnected || !database) {
                console.log('üìÇ Loading from localStorage (Firebase not available)');
                return;
            }

            console.log('üìÇ Attempting to load data from Firebase...');
            database.ref('badmintonClub').once('value')
                .then((snapshot) => {
                    console.log('üìä Firebase snapshot received:', snapshot.exists());
                    
                    if (snapshot.exists()) {
                        const firebaseData = snapshot.val();
                        console.log('üìä Raw Firebase data:', firebaseData);
                        
                        if (firebaseData && firebaseData.players) {
                            console.log('üìÇ Valid Firebase data found, loading...');
                            updateLocalDataFromFirebase(firebaseData);
                        } else {
                            console.log('‚ö†Ô∏è Firebase data exists but no valid players structure');
                            // Initialize with default data and save to Firebase
                            initializePlayers();
                        }
                    } else {
                        console.log('üìÇ No Firebase data exists, initializing defaults');
                        // No Firebase data, initialize with defaults
                        initializePlayers();
                    }
                    
                    isInitializing = false;
                })
                .catch((error) => {
                    console.error('‚ùå Firebase load failed:', error);
                    console.log('üìÇ Falling back to localStorage/defaults');
                    initializePlayers();
                    isInitializing = false;
                });
        }

        // Update local data from Firebase
        function updateLocalDataFromFirebase(firebaseData) {
            console.log('üîÑ updateLocalDataFromFirebase called with:', firebaseData);
            
            if (firebaseData && firebaseData.players) {
                console.log('üìä Firebase players data:', firebaseData.players);
                
                // Ensure players object has the correct structure
                if (firebaseData.players.intermediate && firebaseData.players.beginner) {
                    players = firebaseData.players;
                    
                    // Update courts from Firebase if available
                    if (firebaseData.courts && Array.isArray(firebaseData.courts)) {
                        console.log('üè∏ Syncing court data from Firebase');
                        courts = firebaseData.courts;
                    } else {
                        console.log('üè∏ No court data in Firebase, keeping local courts');
                    // Reset courts if not in Firebase (don't persist games across sessions)
                    courts.forEach(court => {
                        court.occupied = false;
                        court.players = [];
                        court.startTime = null;
                        court.elapsedTime = 0;
                    });
                    
                    // Stop any running timers
                    if (timerInterval) {
                        clearInterval(timerInterval);
                        timerInterval = null;
                    }
                    }
                    
                    // Reset playing status if courts are empty (consistency check)
                    const anyOccupiedCourt = courts.some(court => court.occupied);
                    if (!anyOccupiedCourt) {
                        // No active games, ensure all players are available
                        players.intermediate.forEach(player => {
                            if (player.status === 'playing') {
                                player.status = 'available';
                            }
                        });
                        players.beginner.forEach(player => {
                            if (player.status === 'playing') {
                                player.status = 'available';
                            }
                        });
                    }
                    
                    console.log('‚úÖ Successfully updated local data from Firebase');
                    
                    // Update UI
                    renderPlayers();
                    renderCourts();
                    updateStats();
                    
                    // Save to localStorage as backup
                    savePlayersData();
                } else {
                    console.error('‚ùå Invalid Firebase data structure:', firebaseData.players);
                }
            } else {
                console.log('‚ö†Ô∏è No valid players data in Firebase response');
            }
        }

        // Modified save function that uses Firebase
        function savePlayersDataWithSync() {
            console.log('üîÑ savePlayersDataWithSync called');
            console.log('üî• Firebase connected status:', isFirebaseConnected);
            console.log('üìä Current players data:', players);
            
            if (isFirebaseConnected) {
                console.log('‚úÖ Using Firebase sync');
                saveDataToFirebase();
            } else {
                console.log('üì± Using localStorage only (Firebase not connected)');
                savePlayersData(); // Fallback to localStorage only
            }
        }

        // Initialize the app
        console.log('üöÄ Initializing Badminton Court Manager...');
        
        // Initialize Firebase first
        console.log('üî• Starting Firebase initialization...');
        const firebaseInitResult = initializeFirebase();
        console.log('üî• Firebase init result:', firebaseInitResult);
        
        // Initialize players (will load from Firebase if available, otherwise localStorage/defaults)
        setTimeout(() => {
            if (!isFirebaseConnected) {
                initializePlayers();
                isInitializing = false;
            }
        }, 1000); // Give Firebase a moment to connect

        // PWA Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then((registration) => {
                        console.log('PWA: Service Worker registered successfully:', registration.scope);
                        
                        // Check for updates
                        registration.addEventListener('updatefound', () => {
                            console.log('PWA: New version available');
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // New content is available, show update notification
                                    if (confirm('New version available! Refresh to update?')) {
                                        window.location.reload();
                                    }
                                }
                            });
                        });
                    })
                    .catch((error) => {
                        console.log('PWA: Service Worker registration failed:', error);
                    });
            });
        }

        // PWA Install Prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            console.log('PWA: Install prompt available');
            e.preventDefault();
            deferredPrompt = e;
            
            // Show install button or notification
            showInstallPrompt();
        });

        function showInstallPrompt() {
            // Create install notification
            const installBanner = document.createElement('div');
            installBanner.id = 'install-banner';
            installBanner.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                background: #4caf50;
                color: white;
                padding: 10px 20px;
                border-radius: 25px;
                font-size: 14px;
                z-index: 1000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                cursor: pointer;
                animation: slideDown 0.3s ease;
            `;
            installBanner.innerHTML = 'üì± Install App - Tap here!';
            
            installBanner.addEventListener('click', async () => {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log('PWA: Install prompt result:', outcome);
                    deferredPrompt = null;
                    installBanner.remove();
                }
            });
            
            document.body.appendChild(installBanner);
            
            // Auto-hide after 10 seconds
            setTimeout(() => {
                if (installBanner.parentNode) {
                    installBanner.remove();
                }
            }, 10000);
        }

        // Add slide animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideDown {
                from { transform: translateX(-50%) translateY(-100%); }
                to { transform: translateX(-50%) translateY(0); }
            }
        `;
        document.head.appendChild(style);

        // PWA Installation Success
        window.addEventListener('appinstalled', (evt) => {
            console.log('PWA: App installed successfully');
            // Remove install prompt if still visible
            const installBanner = document.getElementById('install-banner');
            if (installBanner) {
                installBanner.remove();
            }
        });

        // Push notification functions
        let notificationPermission = false;

        // Request notification permission
        async function requestNotificationPermission() {
            if ('Notification' in window) {
                const permission = await Notification.requestPermission();
                notificationPermission = permission === 'granted';
                console.log('üîî Notification permission:', permission);
                
                if (notificationPermission) {
                    showConnectionStatus('üîî Notifications enabled');
                } else {
                    console.log('üîî Notifications denied or not supported');
                }
                
                return notificationPermission;
            }
            return false;
        }

        // Send push notification
        function sendNotification(title, body, data = {}) {
            if (notificationPermission && 'Notification' in window) {
                const notification = new Notification(title, {
                    body: body,
                    icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="50" font-size="50">üè∏</text></svg>',
                    badge: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="50" font-size="50">üè∏</text></svg>',
                    data: data,
                    requireInteraction: false,
                    tag: 'badminton-court'
                });

                notification.onclick = function() {
                    window.focus();
                    this.close();
                };

                // Auto close after 8 seconds
                setTimeout(() => notification.close(), 8000);
                
                console.log('üîî Notification sent:', title);
            }
        }

        // Check if any of the preferred players are assigned (likely app users)
        function checkForPlayerTurn(selectedPlayers) {
            const preferredNames = ['Mohsin', 'Mavia', 'Ali', 'Asad'];
            const selectedPreferred = selectedPlayers.filter(p => 
                preferredNames.some(name => p.name.toLowerCase().includes(name.toLowerCase()))
            );
            
            if (selectedPreferred.length > 0) {
                const names = selectedPreferred.map(p => p.name).join(', ');
                sendNotification(
                    'üéØ Your Turn to Play!',
                    `${names} - You've been assigned to a court!`,
                    { type: 'player_turn', players: names }
                );
            }
        }

        // Initialize notifications when app loads
        window.addEventListener('load', () => {
            // Request notification permission after a short delay
            setTimeout(() => {
                if (!notificationPermission) {
                    requestNotificationPermission();
                }
            }, 2000);
        });

        // Manual Assignment Functions
        let currentCourtForManualAssignment = null;
        let selectedPlayersForManualAssignment = [];

        function openManualAssignment(courtId) {
            currentCourtForManualAssignment = courtId;
            selectedPlayersForManualAssignment = [];
            
            // Show modal
            document.getElementById('manualAssignmentModal').style.display = 'block';
            
            // Update modal title
            document.getElementById('modalCourtTitle').textContent = `Court ${courtId}`;
            
            // Render available players
            renderManualAssignmentPlayers();
            updateSelectedCount();
        }

        function closeManualAssignment() {
            document.getElementById('manualAssignmentModal').style.display = 'none';
            currentCourtForManualAssignment = null;
            selectedPlayersForManualAssignment = [];
        }

        function renderManualAssignmentPlayers() {
            const availableIntermediate = players.intermediate.filter(p => p.status === 'available');
            const availableBeginner = players.beginner.filter(p => p.status === 'available');
            const allAvailable = [...availableIntermediate, ...availableBeginner];

            const container = document.getElementById('playerSelectionContainer');
            container.innerHTML = '';

            if (allAvailable.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No players available for assignment</p>';
                return;
            }

            // Group by level for better organization
            if (availableIntermediate.length > 0) {
                const intermediateHeader = document.createElement('h4');
                intermediateHeader.textContent = `Intermediate Players (${availableIntermediate.length})`;
                intermediateHeader.style.cssText = 'color: #ff9800; margin: 15px 0 10px 0; text-align: center;';
                container.appendChild(intermediateHeader);

                availableIntermediate.forEach(player => {
                    container.appendChild(createPlayerOption(player));
                });
            }

            if (availableBeginner.length > 0) {
                const beginnerHeader = document.createElement('h4');
                beginnerHeader.textContent = `Beginner Players (${availableBeginner.length})`;
                beginnerHeader.style.cssText = 'color: #2196F3; margin: 15px 0 10px 0; text-align: center;';
                container.appendChild(beginnerHeader);

                availableBeginner.forEach(player => {
                    container.appendChild(createPlayerOption(player));
                });
            }
        }

        function createPlayerOption(player) {
            const div = document.createElement('div');
            div.className = `player-option ${player.level}`;
            div.textContent = player.name;
            div.onclick = () => togglePlayerSelection(player);
            return div;
        }

        function togglePlayerSelection(player) {
            const index = selectedPlayersForManualAssignment.findIndex(p => p.id === player.id);
            
            if (index === -1) {
                // Add player if not selected and we have room
                if (selectedPlayersForManualAssignment.length < 4) {
                    selectedPlayersForManualAssignment.push(player);
                } else {
                    alert('You can only select 4 players maximum for a court.');
                    return;
                }
            } else {
                // Remove player if already selected
                selectedPlayersForManualAssignment.splice(index, 1);
            }
            
            updatePlayerSelectionUI();
            updateSelectedCount();
        }

        function updatePlayerSelectionUI() {
            const playerOptions = document.querySelectorAll('.player-option');
            playerOptions.forEach(option => {
                const playerName = option.textContent;
                const isSelected = selectedPlayersForManualAssignment.some(p => p.name === playerName);
                
                if (isSelected) {
                    option.classList.add('selected');
                } else {
                    option.classList.remove('selected');
                }
            });
        }

        function updateSelectedCount() {
            const countElement = document.getElementById('selectedCount');
            const count = selectedPlayersForManualAssignment.length;
            countElement.textContent = `Selected: ${count}/4 players`;
            
            // Update assign button state
            const assignBtn = document.getElementById('manualAssignBtn');
            assignBtn.disabled = count !== 4;
            
            if (count === 4) {
                assignBtn.style.opacity = '1';
                assignBtn.style.cursor = 'pointer';
            } else {
                assignBtn.style.opacity = '0.6';
                assignBtn.style.cursor = 'not-allowed';
            }
        }

        function confirmManualAssignment() {
            if (selectedPlayersForManualAssignment.length !== 4) {
                alert('Please select exactly 4 players.');
                return;
            }

            const court = courts.find(c => c.id === currentCourtForManualAssignment);
            if (!court || court.occupied) {
                alert('Court is not available for assignment.');
                return;
            }

            // Update player status
            selectedPlayersForManualAssignment.forEach(player => {
                if (player.level === 'intermediate') {
                    const playerIndex = players.intermediate.findIndex(p => p.id === player.id);
                    if (playerIndex !== -1) {
                        players.intermediate[playerIndex].status = 'playing';
                    }
                } else {
                    const playerIndex = players.beginner.findIndex(p => p.id === player.id);
                    if (playerIndex !== -1) {
                        players.beginner[playerIndex].status = 'playing';
                    }
                }
            });

            // Update court
            court.occupied = true;
            court.players = selectedPlayersForManualAssignment;

            // Start the timer for this court
            startCourtTimer(currentCourtForManualAssignment);

            // Log the manual assignment
            console.log(`Court ${currentCourtForManualAssignment} (Manual Assignment): Selected players - ${selectedPlayersForManualAssignment.map(p => `${p.name}(${p.level})`).join(', ')}`);

            // Update UI
            renderPlayers();
            renderCourts();
            updateStats();
            
            // Send push notifications
            checkForPlayerTurn(selectedPlayersForManualAssignment);
            
            // Sync to Firebase
            console.log('üè∏ Syncing manual court assignment to Firebase');
            savePlayersDataWithSync();

            // Close modal
            closeManualAssignment();

            // Switch to courts tab on mobile after assigning
            if (isMobile()) {
                setTimeout(() => switchTab('courts'), 100);
            }
        }
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('manualAssignmentModal');
            if (event.target === modal) {
                closeManualAssignment();
            }
        }
    </script>

    <!-- Manual Assignment Modal -->
    <div id="manualAssignmentModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Manual Player Assignment - <span id="modalCourtTitle">Court</span></h2>
                <span class="close" onclick="closeManualAssignment()">&times;</span>
            </div>
            
            <div class="selected-count" id="selectedCount">Selected: 0/4 players</div>
            
            <div id="playerSelectionContainer" class="player-selection">
                <!-- Players will be populated here -->
            </div>
            
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-primary" id="manualAssignBtn" onclick="confirmManualAssignment()" disabled>
                    ‚úÖ Assign Selected Players
                </button>
                <button class="modal-btn modal-btn-secondary" onclick="closeManualAssignment()">
                    ‚ùå Cancel
                </button>
            </div>
        </div>
    </div>
</body>
</html>
